import {loadScene_scene_01} from './loadScene.js';

export const createSceneAndMount_scene_01 = async function (options={}) {
	if(options && options.createViewer == null){
		options.createViewer = true;
	}
	options.sceneData = {"properties":{"frame":9914,"maxFrame":100,"maxFrameLocked":false,"realtimeState":true,"mainCameraPath":"/camera/camera:sopGroup/perspectiveCamera_MAIN","versions":{"polygonjs":"1.2.21"}},"root":{"type":"root","nodes":{"COP":{"type":"copNetwork","nodes":{"imageEXR1":{"type":"imageEXR"},"envMap1":{"type":"envMap","inputs":["imageEXR1"]}}},"einstein":{"type":"geo","nodes":{"fileGLTF1":{"type":"fileGLTF","params":{"url":"models/einstein.glb?timestamp=1652121255046"}},"hierarchy1":{"type":"hierarchy","params":{"mode":1},"inputs":["fileGLTF1"],"cloned_state_overriden":true},"material1":{"type":"material","params":{"material":"../MAT/meshStandard1"},"inputs":["hierarchy1"],"cloned_state_overriden":true},"OUT":{"type":"null","inputs":["material1"],"cloned_state_overriden":true},"objectProperties1":{"type":"objectProperties","params":{"tcastShadow":1},"inputs":["OUT"],"flags":{"display":true},"cloned_state_overriden":true},"MAT":{"type":"materialsNetwork","nodes":{"meshStandard1":{"type":"meshStandard","params":{"useEnvMap":1,"envMap":"../../../COP/envMap1","roughness":0}}}}},"flags":{"display":true}},"bg":{"type":"geo","nodes":{"material1":{"type":"material","params":{"material":"../MAT/meshStandardBuilder1"},"inputs":["transform2"],"flags":{"display":true}},"plane1":{"type":"plane","params":{"direction":[0,0,1]}},"transform2":{"type":"transform","params":{"t":[0,0.5,-0.5],"scale":17},"inputs":["plane1"]},"MAT":{"type":"materialsNetwork","nodes":{"meshStandardBuilder1":{"type":"meshStandardBuilder","nodes":{"globals1":{"type":"globals"},"output1":{"type":"output","inputs":[null,null,{"index":2,"node":"mix1","output":"mix"}]},"disk1":{"type":"disk","params":{"position":{"overriden_options":{}},"center":{"raw_input":[0,0.5],"overriden_options":{}},"radius":{"overriden_options":{}},"feather":{"raw_input":0.02,"overriden_options":{}}},"inputs":[{"index":0,"node":"floatToVec2_1","output":"vec2"}]},"vec3ToFloat1":{"type":"vec3ToFloat","params":{"vec":{"overriden_options":{}}},"inputs":[{"index":0,"node":"globals1","output":"position"}]},"floatToVec2_1":{"type":"floatToVec2","params":{"x":{"overriden_options":{}},"y":{"overriden_options":{}}},"inputs":[{"index":0,"node":"vec3ToFloat1","output":"x"},{"index":1,"node":"vec3ToFloat1","output":"y"}]},"mix1":{"type":"mix","params":{"value0":{"type":"vector3","default_value":[0,0,0],"options":{"spare":true,"editable":false}},"value1":{"type":"vector3","default_value":[0,0,0],"options":{"spare":true,"editable":false}},"blend":{"type":"float","default_value":0.5,"options":{"spare":true,"editable":false}}},"inputs":[{"index":0,"node":"constant2","output":"val"},{"index":1,"node":"constant1","output":"val"},{"index":2,"node":"disk1","output":"float"}],"connection_points":{"in":[{"name":"value0","type":"vec3"},{"name":"value1","type":"vec3"},{"name":"blend","type":"float"}],"out":[{"name":"mix","type":"vec3"}]}},"constant1":{"type":"constant","params":{"type":4,"color":[0.8431372549019608,0.09803921568627451,0.09803921568627451],"asColor":1},"connection_points":{"in":[],"out":[{"name":"val","type":"vec3"}]}},"constant2":{"type":"constant","params":{"type":4,"color":[1,1,1],"asColor":true},"connection_points":{"in":[],"out":[{"name":"val","type":"vec3"}]}}},"persisted_config":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/bg/MAT/meshStandardBuilder1-main","type":"MeshStandardMaterial","name":"/bg/MAT/meshStandardBuilder1","color":16777215,"roughness":1,"metalness":0,"emissive":0,"envMapIntensity":1,"depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680,"fog":false},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[],"timeDependent":false,"resolutionDependent":false},"customMaterials":{"customDepthMaterial":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/bg/MAT/meshStandardBuilder1-customDepthMaterial","type":"MeshDepthMaterial","name":"customDepthMaterial","side":1,"depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680,"depthPacking":3201},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[],"timeDependent":false,"resolutionDependent":false}},"customDistanceMaterial":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/bg/MAT/meshStandardBuilder1-customDistanceMaterial","type":"MeshDistanceMaterial","name":"customDistanceMaterial","depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[],"timeDependent":false,"resolutionDependent":false}},"customDepthDOFMaterial":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/bg/MAT/meshStandardBuilder1-customDepthDOFMaterial","type":"MeshDepthMaterial","name":"customDepthDOFMaterial","depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680,"depthPacking":3200},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[],"timeDependent":false,"resolutionDependent":false}}}}}}}},"flags":{"display":true}},"perspectiveCamera_MAIN":{"type":"perspectiveCamera","nodes":{"postProcessNetwork1":{"type":"postProcessNetwork"},"events1":{"type":"eventsNetwork","nodes":{"cameraOrbitControls1":{"type":"cameraOrbitControls","params":{"target":[-0.0007780588433307105,0.37528316163419373,-0.06528324426926008]}}}}},"params":{"t":[0,0.5,2.6],"controls":"./events1/cameraOrbitControls1"},"flags":{"display":true}},"perspectiveCamera_DEBUG":{"type":"perspectiveCamera","nodes":{"postProcessNetwork1":{"type":"postProcessNetwork"},"events1":{"type":"eventsNetwork","nodes":{"cameraOrbitControls1":{"type":"cameraOrbitControls","params":{"target":[0.0035446049792355063,0.4195304121199609,-0.06366842845239991]}}}}},"params":{"t":[0,0.5,2.3],"controls":"./events1/cameraOrbitControls1"},"flags":{"display":true}},"lights":{"type":"geo","nodes":{"spotLight1":{"type":"spotLight","params":{"intensity":1.4,"penumbra":1.3,"decay":0.55,"castShadow":1}},"polarTransform1":{"type":"polarTransform","params":{"longitude":57.6,"latitude":21.6,"depth":2.1},"inputs":["spotLight1"]},"hemisphereLight1":{"type":"hemisphereLight"},"merge1":{"type":"merge","inputs":["polarTransform1","hemisphereLight1"],"flags":{"display":true},"cloned_state_overriden":true}},"flags":{"display":true}},"camera":{"type":"geo","nodes":{"box1":{"type":"box"},"perspectiveCamera_MAIN":{"type":"perspectiveCamera","params":{"position":[0,0.5,2.5000000000000004]}},"cameraFrameMode1":{"type":"cameraFrameMode","params":{"frameMode":2,"expectedAspectRatio":1},"inputs":["cameraControls1"]},"hierarchy1":{"type":"hierarchy","inputs":["cameraFrameMode1"]},"cameraControls1":{"type":"cameraControls","nodes":{"cameraOrbitControls1":{"type":"cameraOrbitControls","params":{"target":[0,0.5,0]}}},"params":{"node":"cameraOrbitControls1"},"inputs":["perspectiveCamera_MAIN"],"flags":{"bypass":true}},"actor1":{"type":"actor","nodes":{"onTick1":{"type":"onTick"},"setObjectPosition1":{"type":"setObjectPosition","params":{"lerp":0.19},"maxInputsCount":5},"rayFromCursor1":{"type":"rayFromCursor","connection_points":{"in":[],"out":[{"name":"ray","type":"Ray","isArray":false}]}},"plane1":{"type":"plane","params":{"normal":[0,0,1]},"maxInputsCount":0},"rayIntersectPlane1":{"type":"rayIntersectPlane","inputs":[{"index":0,"node":"rayFromCursor1","output":"ray"},{"index":1,"node":"plane1","output":"plane"}],"connection_points":{"in":[{"name":"Ray","type":"Ray","isArray":false},{"name":"Plane","type":"Plane","isArray":false}],"out":[{"name":"position","type":"Vector3","isArray":false}]}},"vec3ToFloat1":{"type":"vec3ToFloat","params":{"vec3":{"overriden_options":{}}},"inputs":[{"index":0,"node":"add1","output":"sum"}]},"floatToVec3_2":{"type":"floatToVec3","params":{"x":{"overriden_options":{}},"y":{"overriden_options":{}},"z":{"overriden_options":{}}},"inputs":[{"index":0,"node":"mult2","output":"product"},{"index":1,"node":"mult1","output":"product"}]},"getObjectProperty1":{"type":"getObjectProperty"},"vec3ToFloat2":{"type":"vec3ToFloat","params":{"vec3":{"overriden_options":{}}},"inputs":[{"index":0,"node":"getObjectProperty1","output":"position"}]},"setObjectLookAt1":{"type":"setObjectLookAt","params":{"targetPosition":[0,0.5,0]},"maxInputsCount":6},"setObjectRotation1":{"type":"setObjectRotation","params":{"rotation":{"overriden_options":{}},"lerp":{"raw_input":0.09,"overriden_options":{}},"updateMatrix":{"overriden_options":{}}},"maxInputsCount":5,"inputs":[{"index":0,"node":"onTick1","output":"trigger"},null,{"index":2,"node":"floatToVec3_2","output":"vec3"}]},"multScalar1":{"type":"multScalar","params":{"value":{"type":"vector3","default_value":[1,1,1],"options":{"spare":true,"editable":false}},"mult":{"type":"float","default_value":1,"options":{"spare":true,"editable":true},"raw_input":0.19}},"inputs":[{"index":0,"node":"vec3ToFloat1","output":"x"}],"connection_points":{"in":[{"name":"value","type":"Vector3","isArray":false},{"name":"mult","type":"float","isArray":false}],"out":[{"name":"val","type":"Vector3","isArray":false}]}},"mult1":{"type":"mult","params":{"mult0":{"type":"float","default_value":1,"options":{"spare":true,"editable":false}},"mult1":{"type":"float","default_value":1,"options":{"spare":true,"editable":true},"raw_input":-0.1}},"inputs":[{"index":0,"node":"vec3ToFloat1","output":"x"}],"connection_points":{"in":[{"name":"mult0","type":"float","isArray":false},{"name":"mult1","type":"float","isArray":false}],"out":[{"name":"product","type":"float","isArray":false}]}},"mult2":{"type":"mult","params":{"mult0":{"type":"float","default_value":1,"options":{"spare":true,"editable":false}},"mult1":{"type":"float","default_value":1,"options":{"spare":true,"editable":true},"raw_input":0.2}},"inputs":[{"index":0,"node":"vec3ToFloat1","output":"y"}],"connection_points":{"in":[{"name":"mult0","type":"float","isArray":false},{"name":"mult1","type":"float","isArray":false}],"out":[{"name":"product","type":"float","isArray":false}]}},"add1":{"type":"add","params":{"add0":{"type":"vector3","default_value":[0,0,0],"options":{"spare":true,"editable":false}},"add1":{"type":"vector3","default_value":[0,0,0],"options":{"spare":true,"editable":true},"raw_input":[0,-0.5,0]}},"inputs":[{"index":0,"node":"rayIntersectPlane1","output":"position"}],"connection_points":{"in":[{"name":"add0","type":"Vector3","isArray":false},{"name":"add1","type":"Vector3","isArray":false}],"out":[{"name":"sum","type":"Vector3","isArray":false}]}}},"inputs":["hierarchy1"],"flags":{"display":true}}},"flags":{"display":true}}},"params":{"backgroundMode":0,"mainCameraPath":"/camera/camera:sopGroup/perspectiveCamera_MAIN"}},"shaders":{"/bg/MAT/meshStandardBuilder1":{"vertex":"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/globals1\n\tv_POLY_globals1_position = vec3(position);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphcolor_vertex>\n// removed:\n//\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n// removed:\n//\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}","fragment":"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/disk1\nfloat disk_feather(float dist, float radius, float feather){\n\tif(feather <= 0.0){\n\t\tif(dist < radius){return 1.0;}else{return 0.0;}\n\t} else {\n\t\tfloat half_feather = feather * 0.5;\n\t\tif(dist < (radius - half_feather)){\n\t\t\treturn 1.0;\n\t\t} else {\n\t\t\tif(dist > (radius + half_feather)){\n\t\t\t\treturn 0.0;\n\t\t\t} else {\n\t\t\t\tfloat feather_start = (radius - half_feather);\n\t\t\t\tfloat blend = 1.0 - (dist - feather_start) / feather;\n\t\t\t\treturn blend;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfloat disk2d(vec2 pos, vec2 center, float radius, float feather){\n\tfloat dist = distance(pos, center);\n\treturn disk_feather(dist, radius, feather);\n}\n\n// function could be called sphere, but is an overload of disk, and is the same\nfloat disk3d(vec3 pos, vec3 center, float radius, float feather){\n\tfloat dist = distance(pos, center);\n\treturn disk_feather(dist, radius, feather);\n}\n\n\n\n\n\n\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nstruct SSSModel {\n\tbool isActive;\n\tvec3 color;\n\tfloat thickness;\n\tfloat power;\n\tfloat scale;\n\tfloat distortion;\n\tfloat ambient;\n\tfloat attenuation;\n};\n\nvoid RE_Direct_Scattering(\n\tconst in IncidentLight directLight,\n\tconst in GeometricContext geometry,\n\tconst in SSSModel sssModel,\n\tinout ReflectedLight reflectedLight\n\t){\n\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * sssModel.distortion));\n\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), sssModel.power) * sssModel.scale;\n\tvec3 scatteringIllu = (scatteringDot + sssModel.ambient) * (sssModel.color * (1.0-sssModel.thickness));\n\treflectedLight.directDiffuse += scatteringIllu * sssModel.attenuation * directLight.color;\n}\n\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/constant2\n\tvec3 v_POLY_constant2_val = vec3(1.0, 1.0, 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant1\n\tvec3 v_POLY_constant1_val = vec3(0.8431372549019608, 0.09803921568627451, 0.09803921568627451);\n\t\n\t// /bg/MAT/meshStandardBuilder1/vec3ToFloat1\n\tfloat v_POLY_vec3ToFloat1_x = v_POLY_globals1_position.x;\n\tfloat v_POLY_vec3ToFloat1_y = v_POLY_globals1_position.y;\n\t\n\t// /bg/MAT/meshStandardBuilder1/floatToVec2_1\n\tvec2 v_POLY_floatToVec2_1_vec2 = vec2(v_POLY_vec3ToFloat1_x, v_POLY_vec3ToFloat1_y);\n\t\n\t// /bg/MAT/meshStandardBuilder1/disk1\n\tfloat v_POLY_disk1_float = disk2d(v_POLY_floatToVec2_1_vec2, vec2(0.0, 0.5), 1.0, 0.02);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mix1\n\tvec3 v_POLY_mix1_mix = mix(v_POLY_constant2_val, v_POLY_constant1_val, v_POLY_disk1_float);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tdiffuseColor.xyz = v_POLY_mix1_mix;\n\tfloat POLY_metalness = 1.0;\n\tfloat POLY_roughness = 1.0;\n\tvec3 POLY_emissive = vec3(1.0, 1.0, 1.0);\n\tSSSModel POLY_SSSModel = SSSModel(/*isActive*/false,/*color*/vec3(1.0, 1.0, 1.0), /*thickness*/0.1, /*power*/2.0, /*scale*/16.0, /*distortion*/0.1,/*ambient*/0.4,/*attenuation*/0.8 );\n\n\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive * POLY_emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat roughnessFactor = roughness * POLY_roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n\n\tfloat metalnessFactor = metalness * POLY_metalness;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\nif(POLY_SSSModel.isActive){\n\tRE_Direct_Scattering(directLight, geometry, POLY_SSSModel, reflectedLight);\n}\n\n\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}","customDepthMaterial.vertex":"#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/globals1\n\tv_POLY_globals1_position = vec3(position);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}","customDepthMaterial.fragment":"\n// INSERT DEFINES\n\n\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/disk1\nfloat disk_feather(float dist, float radius, float feather){\n\tif(feather <= 0.0){\n\t\tif(dist < radius){return 1.0;}else{return 0.0;}\n\t} else {\n\t\tfloat half_feather = feather * 0.5;\n\t\tif(dist < (radius - half_feather)){\n\t\t\treturn 1.0;\n\t\t} else {\n\t\t\tif(dist > (radius + half_feather)){\n\t\t\t\treturn 0.0;\n\t\t\t} else {\n\t\t\t\tfloat feather_start = (radius - half_feather);\n\t\t\t\tfloat blend = 1.0 - (dist - feather_start) / feather;\n\t\t\t\treturn blend;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfloat disk2d(vec2 pos, vec2 center, float radius, float feather){\n\tfloat dist = distance(pos, center);\n\treturn disk_feather(dist, radius, feather);\n}\n\n// function could be called sphere, but is an overload of disk, and is the same\nfloat disk3d(vec3 pos, vec3 center, float radius, float feather){\n\tfloat dist = distance(pos, center);\n\treturn disk_feather(dist, radius, feather);\n}\n\n\n\n\n\n\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nstruct SSSModel {\n\tbool isActive;\n\tvec3 color;\n\tfloat thickness;\n\tfloat power;\n\tfloat scale;\n\tfloat distortion;\n\tfloat ambient;\n\tfloat attenuation;\n};\n\nvoid RE_Direct_Scattering(\n\tconst in IncidentLight directLight,\n\tconst in GeometricContext geometry,\n\tconst in SSSModel sssModel,\n\tinout ReflectedLight reflectedLight\n\t){\n\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * sssModel.distortion));\n\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), sssModel.power) * sssModel.scale;\n\tvec3 scatteringIllu = (scatteringDot + sssModel.ambient) * (sssModel.color * (1.0-sssModel.thickness));\n\treflectedLight.directDiffuse += scatteringIllu * sssModel.attenuation * directLight.color;\n}\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/constant2\n\tvec3 v_POLY_constant2_val = vec3(1.0, 1.0, 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant1\n\tvec3 v_POLY_constant1_val = vec3(0.8431372549019608, 0.09803921568627451, 0.09803921568627451);\n\t\n\t// /bg/MAT/meshStandardBuilder1/vec3ToFloat1\n\tfloat v_POLY_vec3ToFloat1_x = v_POLY_globals1_position.x;\n\tfloat v_POLY_vec3ToFloat1_y = v_POLY_globals1_position.y;\n\t\n\t// /bg/MAT/meshStandardBuilder1/floatToVec2_1\n\tvec2 v_POLY_floatToVec2_1_vec2 = vec2(v_POLY_vec3ToFloat1_x, v_POLY_vec3ToFloat1_y);\n\t\n\t// /bg/MAT/meshStandardBuilder1/disk1\n\tfloat v_POLY_disk1_float = disk2d(v_POLY_floatToVec2_1_vec2, vec2(0.0, 0.5), 1.0, 0.02);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mix1\n\tvec3 v_POLY_mix1_mix = mix(v_POLY_constant2_val, v_POLY_constant1_val, v_POLY_disk1_float);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tdiffuseColor.xyz = v_POLY_mix1_mix;\n\tfloat POLY_metalness = 1.0;\n\tfloat POLY_roughness = 1.0;\n\tvec3 POLY_emissive = vec3(1.0, 1.0, 1.0);\n\tSSSModel POLY_SSSModel = SSSModel(/*isActive*/false,/*color*/vec3(1.0, 1.0, 1.0), /*thickness*/0.1, /*power*/2.0, /*scale*/16.0, /*distortion*/0.1,/*ambient*/0.4,/*attenuation*/0.8 );\n\n\n\n\n\t// INSERT BODY\n\t// the new body lines should be added before the alphatest_fragment\n\t// so that alpha is set before (which is really how it would be set if the alphamap_fragment above was used by the material node parameters)\n\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), diffuseColor.a );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n","customDistanceMaterial.vertex":"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/globals1\n\tv_POLY_globals1_position = vec3(position);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}","customDistanceMaterial.fragment":"\n// INSERT DEFINES\n\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/disk1\nfloat disk_feather(float dist, float radius, float feather){\n\tif(feather <= 0.0){\n\t\tif(dist < radius){return 1.0;}else{return 0.0;}\n\t} else {\n\t\tfloat half_feather = feather * 0.5;\n\t\tif(dist < (radius - half_feather)){\n\t\t\treturn 1.0;\n\t\t} else {\n\t\t\tif(dist > (radius + half_feather)){\n\t\t\t\treturn 0.0;\n\t\t\t} else {\n\t\t\t\tfloat feather_start = (radius - half_feather);\n\t\t\t\tfloat blend = 1.0 - (dist - feather_start) / feather;\n\t\t\t\treturn blend;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfloat disk2d(vec2 pos, vec2 center, float radius, float feather){\n\tfloat dist = distance(pos, center);\n\treturn disk_feather(dist, radius, feather);\n}\n\n// function could be called sphere, but is an overload of disk, and is the same\nfloat disk3d(vec3 pos, vec3 center, float radius, float feather){\n\tfloat dist = distance(pos, center);\n\treturn disk_feather(dist, radius, feather);\n}\n\n\n\n\n\n\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nstruct SSSModel {\n\tbool isActive;\n\tvec3 color;\n\tfloat thickness;\n\tfloat power;\n\tfloat scale;\n\tfloat distortion;\n\tfloat ambient;\n\tfloat attenuation;\n};\n\nvoid RE_Direct_Scattering(\n\tconst in IncidentLight directLight,\n\tconst in GeometricContext geometry,\n\tconst in SSSModel sssModel,\n\tinout ReflectedLight reflectedLight\n\t){\n\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * sssModel.distortion));\n\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), sssModel.power) * sssModel.scale;\n\tvec3 scatteringIllu = (scatteringDot + sssModel.ambient) * (sssModel.color * (1.0-sssModel.thickness));\n\treflectedLight.directDiffuse += scatteringIllu * sssModel.attenuation * directLight.color;\n}\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/constant2\n\tvec3 v_POLY_constant2_val = vec3(1.0, 1.0, 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant1\n\tvec3 v_POLY_constant1_val = vec3(0.8431372549019608, 0.09803921568627451, 0.09803921568627451);\n\t\n\t// /bg/MAT/meshStandardBuilder1/vec3ToFloat1\n\tfloat v_POLY_vec3ToFloat1_x = v_POLY_globals1_position.x;\n\tfloat v_POLY_vec3ToFloat1_y = v_POLY_globals1_position.y;\n\t\n\t// /bg/MAT/meshStandardBuilder1/floatToVec2_1\n\tvec2 v_POLY_floatToVec2_1_vec2 = vec2(v_POLY_vec3ToFloat1_x, v_POLY_vec3ToFloat1_y);\n\t\n\t// /bg/MAT/meshStandardBuilder1/disk1\n\tfloat v_POLY_disk1_float = disk2d(v_POLY_floatToVec2_1_vec2, vec2(0.0, 0.5), 1.0, 0.02);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mix1\n\tvec3 v_POLY_mix1_mix = mix(v_POLY_constant2_val, v_POLY_constant1_val, v_POLY_disk1_float);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tdiffuseColor.xyz = v_POLY_mix1_mix;\n\tfloat POLY_metalness = 1.0;\n\tfloat POLY_roughness = 1.0;\n\tvec3 POLY_emissive = vec3(1.0, 1.0, 1.0);\n\tSSSModel POLY_SSSModel = SSSModel(/*isActive*/false,/*color*/vec3(1.0, 1.0, 1.0), /*thickness*/0.1, /*power*/2.0, /*scale*/16.0, /*distortion*/0.1,/*ambient*/0.4,/*attenuation*/0.8 );\n\n\n\n\n\t// INSERT BODY\n\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n","customDepthDOFMaterial.vertex":"#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/globals1\n\tv_POLY_globals1_position = vec3(position);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}","customDepthDOFMaterial.fragment":"\n// INSERT DEFINES\n\n\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/disk1\nfloat disk_feather(float dist, float radius, float feather){\n\tif(feather <= 0.0){\n\t\tif(dist < radius){return 1.0;}else{return 0.0;}\n\t} else {\n\t\tfloat half_feather = feather * 0.5;\n\t\tif(dist < (radius - half_feather)){\n\t\t\treturn 1.0;\n\t\t} else {\n\t\t\tif(dist > (radius + half_feather)){\n\t\t\t\treturn 0.0;\n\t\t\t} else {\n\t\t\t\tfloat feather_start = (radius - half_feather);\n\t\t\t\tfloat blend = 1.0 - (dist - feather_start) / feather;\n\t\t\t\treturn blend;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfloat disk2d(vec2 pos, vec2 center, float radius, float feather){\n\tfloat dist = distance(pos, center);\n\treturn disk_feather(dist, radius, feather);\n}\n\n// function could be called sphere, but is an overload of disk, and is the same\nfloat disk3d(vec3 pos, vec3 center, float radius, float feather){\n\tfloat dist = distance(pos, center);\n\treturn disk_feather(dist, radius, feather);\n}\n\n\n\n\n\n\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nstruct SSSModel {\n\tbool isActive;\n\tvec3 color;\n\tfloat thickness;\n\tfloat power;\n\tfloat scale;\n\tfloat distortion;\n\tfloat ambient;\n\tfloat attenuation;\n};\n\nvoid RE_Direct_Scattering(\n\tconst in IncidentLight directLight,\n\tconst in GeometricContext geometry,\n\tconst in SSSModel sssModel,\n\tinout ReflectedLight reflectedLight\n\t){\n\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * sssModel.distortion));\n\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), sssModel.power) * sssModel.scale;\n\tvec3 scatteringIllu = (scatteringDot + sssModel.ambient) * (sssModel.color * (1.0-sssModel.thickness));\n\treflectedLight.directDiffuse += scatteringIllu * sssModel.attenuation * directLight.color;\n}\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/constant2\n\tvec3 v_POLY_constant2_val = vec3(1.0, 1.0, 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant1\n\tvec3 v_POLY_constant1_val = vec3(0.8431372549019608, 0.09803921568627451, 0.09803921568627451);\n\t\n\t// /bg/MAT/meshStandardBuilder1/vec3ToFloat1\n\tfloat v_POLY_vec3ToFloat1_x = v_POLY_globals1_position.x;\n\tfloat v_POLY_vec3ToFloat1_y = v_POLY_globals1_position.y;\n\t\n\t// /bg/MAT/meshStandardBuilder1/floatToVec2_1\n\tvec2 v_POLY_floatToVec2_1_vec2 = vec2(v_POLY_vec3ToFloat1_x, v_POLY_vec3ToFloat1_y);\n\t\n\t// /bg/MAT/meshStandardBuilder1/disk1\n\tfloat v_POLY_disk1_float = disk2d(v_POLY_floatToVec2_1_vec2, vec2(0.0, 0.5), 1.0, 0.02);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mix1\n\tvec3 v_POLY_mix1_mix = mix(v_POLY_constant2_val, v_POLY_constant1_val, v_POLY_disk1_float);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tdiffuseColor.xyz = v_POLY_mix1_mix;\n\tfloat POLY_metalness = 1.0;\n\tfloat POLY_roughness = 1.0;\n\tvec3 POLY_emissive = vec3(1.0, 1.0, 1.0);\n\tSSSModel POLY_SSSModel = SSSModel(/*isActive*/false,/*color*/vec3(1.0, 1.0, 1.0), /*thickness*/0.1, /*power*/2.0, /*scale*/16.0, /*distortion*/0.1,/*ambient*/0.4,/*attenuation*/0.8 );\n\n\n\n\n\t// INSERT BODY\n\t// the new body lines should be added before the alphatest_fragment\n\t// so that alpha is set before (which is really how it would be set if the alphamap_fragment above was used by the material node parameters)\n\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), diffuseColor.a );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n"}}};
	return loadScene_scene_01(options);
};
