import {loadScene_scene_02} from './loadScene.js';

export const createSceneAndMount_scene_02 = async function (options={}) {
	if(options && options.createViewer == null){
		options.createViewer = true;
	}
	options.sceneData = {"properties":{"frame":0,"maxFrame":100,"maxFrameLocked":false,"realtimeState":true,"mainCameraPath":"/camera/camera:sopGroup/perspectiveCamera_MAIN","versions":{"polygonjs":"1.2.21"}},"root":{"type":"root","nodes":{"COP":{"type":"copNetwork","nodes":{"envMap1":{"type":"envMap","inputs":["imageEXR1"]},"imageEXR1":{"type":"imageEXR"}}},"bg":{"type":"geo","nodes":{"material1":{"type":"material","params":{"material":"../MAT/meshStandardBuilder1"},"inputs":["transform2"],"flags":{"display":true}},"plane1":{"type":"plane","params":{"direction":[0,0,1]}},"transform2":{"type":"transform","params":{"applyOn":1,"t":[0,0.5,-0.5]},"inputs":["transform3"]},"transform3":{"type":"transform","params":{"scale":17},"inputs":["plane1"]},"MAT":{"type":"materialsNetwork","nodes":{"meshStandardBuilder1":{"type":"meshStandardBuilder","nodes":{"constant1":{"type":"constant","params":{"type":4,"color":[0.8431372549019608,0.09803921568627451,0.09803921568627451],"asColor":true},"connection_points":{"in":[],"out":[{"name":"val","type":"vec3"}]}},"constant2":{"type":"constant","params":{"type":4,"color":[1,1,1],"asColor":true},"connection_points":{"in":[],"out":[{"name":"val","type":"vec3"}]}},"globals1":{"type":"globals"},"mix1":{"type":"mix","params":{"value0":{"type":"vector3","default_value":[0,0,0],"options":{"spare":true,"editable":false}},"value1":{"type":"vector3","default_value":[0,0,0],"options":{"spare":true,"editable":false}},"blend":{"type":"float","default_value":0.5,"options":{"spare":true,"editable":false}}},"inputs":[{"index":0,"node":"oklabToRgb1","output":"rgb"},{"index":1,"node":"constant2","output":"val"},{"index":2,"node":"smoothstep4","output":"val"}],"connection_points":{"in":[{"name":"value0","type":"vec3"},{"name":"value1","type":"vec3"},{"name":"blend","type":"float"}],"out":[{"name":"mix","type":"vec3"}]}},"output1":{"type":"output","inputs":[null,null,{"index":2,"node":"mix1","output":"mix"}]},"SDFBox2":{"type":"SDFBox","params":{"position":{"overriden_options":{}},"center":{"overriden_options":{}},"size":{"raw_input":0.42,"overriden_options":{}},"sizes":{"overriden_options":{}}},"inputs":[{"index":0,"node":"globals1","output":"position"}]},"rgbToOklab1":{"type":"rgbToOklab","params":{"rgb":{"overriden_options":{}}},"inputs":[{"index":0,"node":"constant1","output":"val"}]},"oklabToRgb1":{"type":"oklabToRgb","params":{"oklab":{"overriden_options":{}}},"inputs":[{"index":0,"node":"mix4","output":"mix"}]},"mult3":{"type":"mult","params":{"mult0":{"type":"float","default_value":1,"options":{"spare":true,"editable":false}},"mult1":{"type":"float","default_value":1,"options":{"spare":true,"editable":false}},"mult2":{"type":"float","default_value":1,"options":{"spare":true,"editable":true}}},"maxInputsCount":3,"inputs":[{"index":0,"node":"complement3","output":"val"},{"index":1,"node":"constant3","output":"val"}],"connection_points":{"in":[{"name":"mult0","type":"float"},{"name":"mult1","type":"float"},{"name":"mult2","type":"float"}],"out":[{"name":"product","type":"float"}]}},"constant3":{"type":"constant","params":{"float":14},"connection_points":{"in":[],"out":[{"name":"val","type":"float"}]}},"round1":{"type":"round","params":{"in":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}}},"inputs":[{"index":0,"node":"mult3","output":"product"}],"connection_points":{"in":[{"name":"in","type":"float"}],"out":[{"name":"val","type":"float"}]}},"divide1":{"type":"divide","params":{"div0":{"type":"float","default_value":1,"options":{"spare":true,"editable":false}},"div1":{"type":"float","default_value":1,"options":{"spare":true,"editable":false}},"div2":{"type":"float","default_value":1,"options":{"spare":true,"editable":true}}},"maxInputsCount":3,"inputs":[{"index":0,"node":"round1","output":"val"},{"index":1,"node":"constant3","output":"val"}],"connection_points":{"in":[{"name":"div0","type":"float"},{"name":"div1","type":"float"},{"name":"div2","type":"float"}],"out":[{"name":"divide","type":"float"}]}},"multAdd5":{"type":"multAdd","params":{"value":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"preAdd":{"type":"float","default_value":0,"options":{"spare":true,"editable":true},"raw_input":-0.2},"mult":{"type":"float","default_value":1,"options":{"spare":true,"editable":true}},"postAdd":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}}},"inputs":[{"index":0,"node":"null1","output":"val"}],"connection_points":{"in":[{"name":"value","type":"float"},{"name":"preAdd","type":"float"},{"name":"mult","type":"float"},{"name":"postAdd","type":"float"}],"out":[{"name":"val","type":"float"}]}},"fit1":{"type":"fit","params":{"val":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"srcMin":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}},"srcMax":{"type":"float","default_value":1,"options":{"spare":true,"editable":true}},"destMin":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}},"destMax":{"type":"float","default_value":1,"options":{"spare":true,"editable":true},"raw_input":0.9}},"inputs":[{"index":0,"node":"null1","output":"val"}],"connection_points":{"in":[{"name":"val","type":"float"},{"name":"srcMin","type":"float"},{"name":"srcMax","type":"float"},{"name":"destMin","type":"float"},{"name":"destMax","type":"float"}],"out":[{"name":"val","type":"float"}]}},"constant4":{"type":"constant","params":{"type":4,"color":[0.08235294117647059,0.043137254901960784,0.615686274509804],"asColor":true},"connection_points":{"in":[],"out":[{"name":"val","type":"vec3"}]}},"rgbToOklab3":{"type":"rgbToOklab","params":{"rgb":{"overriden_options":{}}},"inputs":[{"index":0,"node":"constant4","output":"val"}]},"mix4":{"type":"mix","params":{"value0":{"type":"vector3","default_value":[0,0,0],"options":{"spare":true,"editable":false}},"value1":{"type":"vector3","default_value":[0,0,0],"options":{"spare":true,"editable":false}},"blend":{"type":"float","default_value":0.5,"options":{"spare":true,"editable":false},"raw_input":1}},"inputs":[{"index":0,"node":"rgbToOklab3","output":"oklab"},{"index":1,"node":"rgbToOklab1","output":"oklab"},{"index":2,"node":"divide1","output":"divide"}],"connection_points":{"in":[{"name":"value0","type":"vec3"},{"name":"value1","type":"vec3"},{"name":"blend","type":"float"}],"out":[{"name":"mix","type":"vec3"}]}},"smoothstep4":{"type":"smoothstep","params":{"edge0":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}},"edge1":{"type":"float","default_value":1,"options":{"spare":true,"editable":true},"raw_input":0.01},"x":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}}},"inputs":[null,null,{"index":2,"node":"multAdd5","output":"val"}],"connection_points":{"in":[{"name":"edge0","type":"float"},{"name":"edge1","type":"float"},{"name":"x","type":"float"}],"out":[{"name":"val","type":"float"}]}},"complement3":{"type":"complement","params":{"in":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}}},"inputs":[{"index":0,"node":"fit1","output":"val"}],"connection_points":{"in":[{"name":"in","type":"float"}],"out":[{"name":"val","type":"float"}]}},"null1":{"type":"null","params":{"in":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}}},"inputs":[{"index":0,"node":"SDFUnion2","output":"union"}],"connection_points":{"in":[{"name":"in","type":"float"}],"out":[{"name":"val","type":"float"}]}},"SDFSphere1":{"type":"SDFSphere","params":{"position":{"overriden_options":{}},"center":{"raw_input":[-0.5,0,0],"overriden_options":{}},"radius":{"raw_input":0.32999999999999996,"overriden_options":{}}},"inputs":[{"index":0,"node":"globals1","output":"position"},{"index":1,"node":"floatToVec3_1","output":"vec3"}]},"param1":{"type":"param","params":{"name":"blobPos","type":4},"connection_points":{"in":[],"out":[{"name":"val","type":"vec3"}]}},"vec3ToFloat1":{"type":"vec3ToFloat","params":{"vec":{"overriden_options":{}}},"inputs":[{"index":0,"node":"param1","output":"val"}]},"floatToVec3_1":{"type":"floatToVec3","params":{"x":{"overriden_options":{}},"y":{"overriden_options":{}},"z":{"overriden_options":{}}},"inputs":[{"index":0,"node":"vec3ToFloat1","output":"x"},{"index":1,"node":"multAdd1","output":"val"}]},"multAdd1":{"type":"multAdd","params":{"value":{"type":"float","default_value":0,"options":{"spare":true,"editable":false}},"preAdd":{"type":"float","default_value":0,"options":{"spare":true,"editable":true},"raw_input":-0.5},"mult":{"type":"float","default_value":1,"options":{"spare":true,"editable":true}},"postAdd":{"type":"float","default_value":0,"options":{"spare":true,"editable":true}}},"inputs":[{"index":0,"node":"vec3ToFloat1","output":"y"}],"connection_points":{"in":[{"name":"value","type":"float"},{"name":"preAdd","type":"float"},{"name":"mult","type":"float"},{"name":"postAdd","type":"float"}],"out":[{"name":"val","type":"float"}]}},"SDFUnion2":{"type":"SDFUnion","params":{"sdf0":{"type":"float","default_value":0,"options":{"spare":true,"editable":false},"overriden_options":{}},"sdf1":{"type":"float","default_value":0,"options":{"spare":true,"editable":false},"overriden_options":{}},"smoothFactor":{"type":"float","default_value":0,"options":{"spare":true,"editable":true},"raw_input":0.39}},"inputs":[{"index":0,"node":"SDFSphere1","output":"float"},{"index":1,"node":"SDFBox2","output":"float"}],"connection_points":{"in":[{"name":"sdf0","type":"float"},{"name":"sdf1","type":"float"},{"name":"smoothFactor","type":"float"}],"out":[{"name":"union","type":"float"}]}}},"params":{"blobPos":{"type":"vector3","default_value":[0,0,0],"options":{"spare":true,"computeOnDirty":true,"cook":false,"dependentOnFoundNode":true},"raw_input":[1.89463716546616,-0.8221597623594306,-0.5],"overriden_options":{"callback":"{}"}}},"persisted_config":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/bg/MAT/meshStandardBuilder1-main","type":"MeshStandardMaterial","name":"/bg/MAT/meshStandardBuilder1","color":16777215,"roughness":1,"metalness":0,"emissive":0,"envMapIntensity":1,"depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680,"fog":false},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[{"type":"vector3","name":"blobPos","defaultValue":[0,0,0],"uniformName":"v_POLY_param_blobPos"}],"timeDependent":false,"resolutionDependent":false},"customMaterials":{"customDepthMaterial":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/bg/MAT/meshStandardBuilder1-customDepthMaterial","type":"MeshDepthMaterial","name":"customDepthMaterial","side":1,"depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680,"depthPacking":3201},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[{"type":"vector3","name":"blobPos","defaultValue":[0,0,0],"uniformName":"v_POLY_param_blobPos"}],"timeDependent":false,"resolutionDependent":false}},"customDistanceMaterial":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/bg/MAT/meshStandardBuilder1-customDistanceMaterial","type":"MeshDistanceMaterial","name":"customDistanceMaterial","depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[{"type":"vector3","name":"blobPos","defaultValue":[0,0,0],"uniformName":"v_POLY_param_blobPos"}],"timeDependent":false,"resolutionDependent":false}},"customDepthDOFMaterial":{"material":{"metadata":{"version":4.5,"type":"Material","generator":"Material.toJSON"},"uuid":"/bg/MAT/meshStandardBuilder1-customDepthDOFMaterial","type":"MeshDepthMaterial","name":"customDepthDOFMaterial","depthFunc":3,"depthTest":true,"depthWrite":true,"colorWrite":true,"stencilWrite":false,"stencilWriteMask":255,"stencilFunc":519,"stencilRef":0,"stencilFuncMask":255,"stencilFail":7680,"stencilZFail":7680,"stencilZPass":7680,"depthPacking":3200},"onBeforeCompileDataJSONWithoutShaders":{"paramConfigs":[{"type":"vector3","name":"blobPos","defaultValue":[0,0,0],"uniformName":"v_POLY_param_blobPos"}],"timeDependent":false,"resolutionDependent":false}}}}},"eventsNetwork1":{"type":"eventsNetwork","nodes":{"pointer1":{"type":"pointer","params":{"pointerdown":0,"pointermove":1}},"raycast1":{"type":"raycast","params":{"mouse":[0.8525518694987595,-0.9451269201330237],"intersectWith":1,"planeDirection":[0,0,1],"planeOffset":0.5,"tpositionTarget":1,"position":[1.5407502150851677,-0.39727143467284565,0],"positionTarget":"../../meshStandardBuilder1/blobPos"},"inputs":[{"index":0,"node":"pointer1","output":"pointermove"}]}}}}}},"flags":{"display":true}},"perspectiveCamera_MAIN":{"type":"perspectiveCamera","nodes":{"postProcessNetwork1":{"type":"postProcessNetwork"},"events1":{"type":"eventsNetwork","nodes":{"cameraOrbitControls1":{"type":"cameraOrbitControls","params":{"target":[-0.0007780588433307105,0.37528316163419373,-0.06528324426926008]}}}}},"params":{"t":[0,0.5,2.6],"controls":"./events1/cameraOrbitControls1"},"flags":{"display":true}},"perspectiveCamera_DEBUG":{"type":"perspectiveCamera","nodes":{"postProcessNetwork1":{"type":"postProcessNetwork"},"events1":{"type":"eventsNetwork","nodes":{"cameraOrbitControls1":{"type":"cameraOrbitControls","params":{"target":[0.0035446049792355063,0.4195304121199609,-0.06366842845239991]}}}}},"params":{"t":[0,0.5,2.3],"controls":"./events1/cameraOrbitControls1"},"flags":{"display":true}},"lights":{"type":"geo","nodes":{"hemisphereLight1":{"type":"hemisphereLight"},"merge1":{"type":"merge","inputs":["polarTransform1","hemisphereLight1"],"flags":{"display":true},"cloned_state_overriden":true},"polarTransform1":{"type":"polarTransform","params":{"longitude":57.6,"latitude":21.6,"depth":2.1},"inputs":["spotLight1"]},"spotLight1":{"type":"spotLight","params":{"intensity":1.4,"penumbra":1.3,"decay":0.55,"castShadow":true}}},"flags":{"display":true}},"camera":{"type":"geo","nodes":{"box1":{"type":"box"},"cameraFrameMode1":{"type":"cameraFrameMode","params":{"frameMode":2,"expectedAspectRatio":1},"inputs":["cameraControls1"]},"hierarchy1":{"type":"hierarchy","inputs":["cameraFrameMode1"]},"perspectiveCamera_MAIN":{"type":"perspectiveCamera","params":{"position":[0,0.5,2.5000000000000004]}},"actor1":{"type":"actor","nodes":{"add1":{"type":"add","params":{"add0":{"type":"vector3","default_value":[0,0,0],"options":{"spare":true,"editable":false}},"add1":{"type":"vector3","default_value":[0,0,0],"options":{"spare":true,"editable":true},"raw_input":[0,-0.5,0]}},"inputs":[{"index":0,"node":"rayIntersectPlane1","output":"position"}],"connection_points":{"in":[{"name":"add0","type":"Vector3","isArray":false},{"name":"add1","type":"Vector3","isArray":false}],"out":[{"name":"sum","type":"Vector3","isArray":false}]}},"floatToVec3_2":{"type":"floatToVec3","params":{"x":{"overriden_options":{}},"y":{"overriden_options":{}},"z":{"overriden_options":{}}},"inputs":[{"index":0,"node":"mult2","output":"product"},{"index":1,"node":"mult1","output":"product"}]},"getObjectProperty1":{"type":"getObjectProperty"},"mult1":{"type":"mult","params":{"mult0":{"type":"float","default_value":1,"options":{"spare":true,"editable":false}},"mult1":{"type":"float","default_value":1,"options":{"spare":true,"editable":true},"raw_input":-0.1}},"inputs":[{"index":0,"node":"vec3ToFloat1","output":"x"}],"connection_points":{"in":[{"name":"mult0","type":"float","isArray":false},{"name":"mult1","type":"float","isArray":false}],"out":[{"name":"product","type":"float","isArray":false}]}},"mult2":{"type":"mult","params":{"mult0":{"type":"float","default_value":1,"options":{"spare":true,"editable":false}},"mult1":{"type":"float","default_value":1,"options":{"spare":true,"editable":true},"raw_input":0.2}},"inputs":[{"index":0,"node":"vec3ToFloat1","output":"y"}],"connection_points":{"in":[{"name":"mult0","type":"float","isArray":false},{"name":"mult1","type":"float","isArray":false}],"out":[{"name":"product","type":"float","isArray":false}]}},"multScalar1":{"type":"multScalar","params":{"value":{"type":"vector3","default_value":[1,1,1],"options":{"spare":true,"editable":false}},"mult":{"type":"float","default_value":1,"options":{"spare":true,"editable":true},"raw_input":0.19}},"inputs":[{"index":0,"node":"vec3ToFloat1","output":"x"}],"connection_points":{"in":[{"name":"value","type":"Vector3","isArray":false},{"name":"mult","type":"float","isArray":false}],"out":[{"name":"val","type":"Vector3","isArray":false}]}},"onTick1":{"type":"onTick"},"plane1":{"type":"plane","params":{"normal":[0,0,1]},"maxInputsCount":0},"rayFromCursor1":{"type":"rayFromCursor","connection_points":{"in":[],"out":[{"name":"ray","type":"Ray","isArray":false}]}},"rayIntersectPlane1":{"type":"rayIntersectPlane","inputs":[{"index":0,"node":"rayFromCursor1","output":"ray"},{"index":1,"node":"plane1","output":"plane"}],"connection_points":{"in":[{"name":"Ray","type":"Ray","isArray":false},{"name":"Plane","type":"Plane","isArray":false}],"out":[{"name":"position","type":"Vector3","isArray":false}]}},"setObjectLookAt1":{"type":"setObjectLookAt","params":{"targetPosition":[0,0.5,0]},"maxInputsCount":6},"setObjectPosition1":{"type":"setObjectPosition","params":{"lerp":0.19},"maxInputsCount":5},"setObjectRotation1":{"type":"setObjectRotation","params":{"rotation":{"overriden_options":{}},"lerp":{"raw_input":0.09,"overriden_options":{}},"updateMatrix":{"overriden_options":{}}},"maxInputsCount":5,"inputs":[{"index":0,"node":"onTick1","output":"trigger"},null,{"index":2,"node":"floatToVec3_2","output":"vec3"}]},"vec3ToFloat1":{"type":"vec3ToFloat","params":{"vec3":{"overriden_options":{}}},"inputs":[{"index":0,"node":"add1","output":"sum"}]},"vec3ToFloat2":{"type":"vec3ToFloat","params":{"vec3":{"overriden_options":{}}},"inputs":[{"index":0,"node":"getObjectProperty1","output":"position"}]}},"inputs":["hierarchy1"],"flags":{"display":true}},"cameraControls1":{"type":"cameraControls","nodes":{"cameraOrbitControls1":{"type":"cameraOrbitControls","params":{"target":[0,0.5,0]}}},"params":{"node":"cameraOrbitControls1"},"inputs":["perspectiveCamera_MAIN"],"flags":{"bypass":true}}},"flags":{"display":true}},"rhino":{"type":"geo","nodes":{"OUT":{"type":"null","inputs":["material1"],"cloned_state_overriden":true},"fileGLTF1":{"type":"fileGLTF","params":{"url":"models/rhino.glb?timestamp=1652121258378"}},"hierarchy1":{"type":"hierarchy","params":{"mode":1},"inputs":["fileGLTF1"],"cloned_state_overriden":true},"material1":{"type":"material","params":{"material":"../MAT/meshStandard1"},"inputs":["hierarchy1"],"cloned_state_overriden":true},"objectProperties1":{"type":"objectProperties","params":{"tcastShadow":true},"inputs":["OUT"],"flags":{"display":true},"cloned_state_overriden":true},"MAT":{"type":"materialsNetwork","nodes":{"meshStandard1":{"type":"meshStandard","params":{"useEnvMap":true,"envMap":"../../../COP/envMap1","roughness":0}}}}},"flags":{"display":true}}},"params":{"mainCameraPath":"/camera/camera:sopGroup/perspectiveCamera_MAIN"}},"shaders":{"/bg/MAT/meshStandardBuilder1":{"vertex":"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/globals1\n\tv_POLY_globals1_position = vec3(position);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphcolor_vertex>\n// removed:\n//\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n// removed:\n//\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}","fragment":"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/rgbToOklab3\n//////////////////////////////////////////////////////////////////////\n//\n// Visualizing Björn Ottosson's \"oklab\" colorspace\n//\n// shadertoy implementation by mattz\n//\n// license CC0 (public domain)\n// https://creativecommons.org/share-your-work/public-domain/cc0/\n//\n// Click and drag to set lightness (mouse x) and chroma (mouse y).\n// Hue varies linearly across the image from left to right.\n//\n// While mouse is down, plotted curves show oklab components\n// L (red), a (green), and b (blue). \n//\n// To test the inverse mapping, the plotted curves are generated\n// by mapping the (pre-clipping) linear RGB color back to oklab \n// space.\n//\n// White bars on top of the image (and black bars on the bottom of\n// the image) indicate clipping when one or more of the R, G, B \n// components are greater than 1.0 (or less than 0.0 respectively).\n//\n// The color accompanying the black/white bar shows which channels\n// are out of gamut.\n//\n// Click in the bottom left to reset the view.\n//\n// Hit the 'G' key to toggle displaying a gamut test:\n//\n//   * black pixels indicate that RGB values for some hues\n//     were clipped to 0 at the given lightness/chroma pair.\n//\n//   * white pixels indicate that RGB values for some hues\n//     were clipped to 1 at the given lightness/chroma pair\n//\n//   * gray pixels indicate that both types of clipping happened\n//\n// Hit the 'U' key to display a uniform sampling of linear sRGB \n// space, converted into oklab lightness (x position) and chroma\n// (y position) coordinates. If you mouse over a colored dot, the\n// spectrum on screen should include that exact color.\n//\n//////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////\n// sRGB color transform and inverse from \n// https://bottosson.github.io/posts/colorwrong/#what-can-we-do%3F\n\nvec3 srgb_from_linear_srgb(vec3 x) {\n\n    vec3 xlo = 12.92*x;\n    vec3 xhi = 1.055 * pow(x, vec3(0.4166666666666667)) - 0.055;\n    \n    return mix(xlo, xhi, step(vec3(0.0031308), x));\n\n}\n\nvec3 linear_srgb_from_srgb(vec3 x) {\n\n    vec3 xlo = x / 12.92;\n    vec3 xhi = pow((x + 0.055)/(1.055), vec3(2.4));\n    \n    return mix(xlo, xhi, step(vec3(0.04045), x));\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// oklab transform and inverse from\n// https://bottosson.github.io/posts/oklab/\n\n\nconst mat3 fwdA = mat3(1.0, 1.0, 1.0,\n                       0.3963377774, -0.1055613458, -0.0894841775,\n                       0.2158037573, -0.0638541728, -1.2914855480);\n                       \nconst mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,\n                       -3.3072168827, 2.6093323231, -0.7034763098,\n                       0.2307590544, -0.3411344290,  1.7068625689);\n\nconst mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,\n                       0.5362752080, 0.6807189584, 0.2818474174,\n                       0.0514575653, 0.1074065790, 0.6302613616);\n                       \nconst mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,\n                       0.7936177850, -2.4285922050, 0.7827717662,\n                       -0.0040720468, 0.4505937099, -0.8086757660);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n\n    vec3 lms = invB * c;\n            \n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n    \n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n\n    vec3 lms = fwdA * c;\n    \n    return fwdB * (lms * lms * lms);\n    \n}\n\n\n// https://www.shadertoy.com/view/WtccD7\nconst float max_chroma = 0.33;\nvec3 uvToOklab(vec3 uvw){\n\n    // setup oklab color\n    float theta = 2.*3.141592653589793*uvw.x;\n    \n    float L = 0.8;\n    float chroma = 0.1;\n    \n    //if (max(iMouse.x, iMouse.y) > 0.05 * iResolution.y) {\n        L = uvw.y;//iMouse.x / iResolution.x;\n        chroma = uvw.z * max_chroma;// / iResolution.y;\n    //}\n    \n    float a = chroma*cos(theta);\n    float b = chroma*sin(theta);\n    \n    vec3 lab = vec3(L, a, b);\n\treturn lab;\n\n    // convert to rgb \n    // vec3 rgb = linear_srgb_from_oklab(lab);\n\n}\n\n// /bg/MAT/meshStandardBuilder1/SDFBox2\n// https://iquilezles.org/articles/distfunctions/\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n/*\n*\n* SDF PRIMITIVES\n*\n*/\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n\t\tp = abs(p  )-b;\n\tvec3 q = abs(p+e)-e;\n\treturn min(min(\n\t\tlength(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n\t\tlength(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n\t\tlength(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n\tp.y -= clamp( p.y, 0.0, h );\n\treturn length( p ) - r;\n}\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n\t// c is the sin/cos of the angle, h is height\n\t// Alternatively pass q instead of (c,h),\n\t// which is the point at the base in 2D\n\tvec2 q = h*vec2(c.x/c.y,-1.0);\n\n\tvec2 w = vec2( length(p.xz), p.y );\n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n\tvec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n\tfloat k = sign( q.y );\n\tfloat d = min(dot( a, a ),dot(b, b));\n\tfloat s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\nfloat sdConeWrapped(vec3 pos, float angle, float height){\n\treturn sdCone(pos, vec2(sin(angle), cos(angle)), height);\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n\tfloat b = (r1-r2)/h;\n\tfloat a = sqrt(1.0-b*b);\n\n\tvec2 q = vec2( length(p.xz), p.y );\n\tfloat k = dot(q,vec2(-b,a));\n\tif( k<0.0 ) return length(q) - r1;\n\tif( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n\treturn dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n\t// n must be normalized\n\treturn dot(p,n) + h;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n\tp.x = abs(p.x);\n\tfloat k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n\treturn sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float radius)\n{\n\tvec2 p = vec2( length(pos.xz), pos.y );\n\tfloat l = length(p) - radius;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,radius) );\n\treturn max(l,m*sign(c.y*p.x-c.x*p.y));\n}\nfloat sdSolidAngleWrapped(vec3 pos, float angle, float radius){\n\treturn sdSolidAngle(pos, vec2(sin(angle), cos(angle)), radius);\n}\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n/*\n*\n* SDF OPERATIONS\n*\n*/\nfloat SDFUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat SDFSubtract( float d1, float d2 ) { return max(-d1,d2); }\nfloat SDFIntersect( float d1, float d2 ) { return max(d1,d2); }\n\nfloat SDFSmoothUnion( float d1, float d2, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat SDFSmoothSubtract( float d1, float d2, float k ) {\n\tfloat h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\treturn mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat SDFSmoothIntersect( float d1, float d2, float k ) {\n\tfloat h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nvec4 SDFElongateFast( in vec3 p, in vec3 h )\n{\n\treturn vec4( p-clamp(p,-h,h), 0.0 );\n}\nvec4 SDFElongateSlow( in vec3 p, in vec3 h )\n{\n\tvec3 q = abs(p)-h;\n\treturn vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat SDFOnion( in float sdf, in float thickness )\n{\n\treturn abs(sdf)-thickness;\n}\n\n// /bg/MAT/meshStandardBuilder1/fit1\n//\n//\n// FIT\n//\n//\nfloat fit(float val, float srcMin, float srcMax, float destMin, float destMax){\n\tfloat src_range = srcMax - srcMin;\n\tfloat dest_range = destMax - destMin;\n\n\tfloat r = (val - srcMin) / src_range;\n\treturn (r * dest_range) + destMin;\n}\nvec2 fit(vec2 val, vec2 srcMin, vec2 srcMax, vec2 destMin, vec2 destMax){\n\treturn vec2(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y)\n\t);\n}\nvec3 fit(vec3 val, vec3 srcMin, vec3 srcMax, vec3 destMin, vec3 destMax){\n\treturn vec3(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z)\n\t);\n}\nvec4 fit(vec4 val, vec4 srcMin, vec4 srcMax, vec4 destMin, vec4 destMax){\n\treturn vec4(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z),\n\t\tfit(val.w, srcMin.w, srcMax.w, destMin.w, destMax.w)\n\t);\n}\n\n//\n//\n// FIT TO 01\n// fits the range [srcMin, srcMax] to [0, 1]\n//\nfloat fitTo01(float val, float srcMin, float srcMax){\n\tfloat size = srcMax - srcMin;\n\treturn (val - srcMin) / size;\n}\nvec2 fitTo01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitTo01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitTo01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z),\n\t\tfitTo01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01\n// fits the range [0, 1] to [destMin, destMax]\n//\nfloat fitFrom01(float val, float destMin, float destMax){\n\treturn fit(val, 0.0, 1.0, destMin, destMax);\n}\nvec2 fitFrom01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitFrom01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitFrom01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z),\n\t\tfitFrom01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01 TO VARIANCE\n// fits the range [0, 1] to [center - variance, center + variance]\n//\nfloat fitFrom01ToVariance(float val, float center, float variance){\n\treturn fitFrom01(val, center - variance, center + variance);\n}\nvec2 fitFrom01ToVariance(vec2 val, vec2 center, vec2 variance){\n\treturn vec2(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y)\n\t);\n}\nvec3 fitFrom01ToVariance(vec3 val, vec3 center, vec3 variance){\n\treturn vec3(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z)\n\t);\n}\nvec4 fitFrom01ToVariance(vec4 val, vec4 center, vec4 variance){\n\treturn vec4(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z),\n\t\tfitFrom01ToVariance(val.w, center.w, variance.w)\n\t);\n}\n\n// /bg/MAT/meshStandardBuilder1/complement3\nfloat complement(float x){return 1.0-x;}\nvec2 complement(vec2 x){return vec2(1.0-x.x, 1.0-x.y);}\nvec3 complement(vec3 x){return vec3(1.0-x.x, 1.0-x.y, 1.0-x.z);}\nvec4 complement(vec4 x){return vec4(1.0-x.x, 1.0-x.y, 1.0-x.z, 1.0-x.w);}\n\n\n\n\n\n\n\n\n// /bg/MAT/meshStandardBuilder1/param1\nuniform vec3 v_POLY_param_blobPos;\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nstruct SSSModel {\n\tbool isActive;\n\tvec3 color;\n\tfloat thickness;\n\tfloat power;\n\tfloat scale;\n\tfloat distortion;\n\tfloat ambient;\n\tfloat attenuation;\n};\n\nvoid RE_Direct_Scattering(\n\tconst in IncidentLight directLight,\n\tconst in GeometricContext geometry,\n\tconst in SSSModel sssModel,\n\tinout ReflectedLight reflectedLight\n\t){\n\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * sssModel.distortion));\n\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), sssModel.power) * sssModel.scale;\n\tvec3 scatteringIllu = (scatteringDot + sssModel.ambient) * (sssModel.color * (1.0-sssModel.thickness));\n\treflectedLight.directDiffuse += scatteringIllu * sssModel.attenuation * directLight.color;\n}\n\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/constant4\n\tvec3 v_POLY_constant4_val = vec3(0.08235294117647059, 0.043137254901960784, 0.615686274509804);\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant1\n\tvec3 v_POLY_constant1_val = vec3(0.8431372549019608, 0.09803921568627451, 0.09803921568627451);\n\t\n\t// /bg/MAT/meshStandardBuilder1/param1\n\tvec3 v_POLY_param1_val = v_POLY_param_blobPos;\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant3\n\tfloat v_POLY_constant3_val = 14.0;\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant2\n\tvec3 v_POLY_constant2_val = vec3(1.0, 1.0, 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/rgbToOklab3\n\tvec3 v_POLY_rgbToOklab3_oklab = oklab_from_linear_srgb(v_POLY_constant4_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/rgbToOklab1\n\tvec3 v_POLY_rgbToOklab1_oklab = oklab_from_linear_srgb(v_POLY_constant1_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/SDFBox2\n\tfloat v_POLY_SDFBox2_float = sdBox(v_POLY_globals1_position - vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0)*0.42);\n\t\n\t// /bg/MAT/meshStandardBuilder1/vec3ToFloat1\n\tfloat v_POLY_vec3ToFloat1_x = v_POLY_param1_val.x;\n\tfloat v_POLY_vec3ToFloat1_y = v_POLY_param1_val.y;\n\t\n\t// /bg/MAT/meshStandardBuilder1/multAdd1\n\tfloat v_POLY_multAdd1_val = (1.0*(v_POLY_vec3ToFloat1_y + -0.5)) + 0.0;\n\t\n\t// /bg/MAT/meshStandardBuilder1/floatToVec3_1\n\tvec3 v_POLY_floatToVec3_1_vec3 = vec3(v_POLY_vec3ToFloat1_x, v_POLY_multAdd1_val, 0.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/SDFSphere1\n\tfloat v_POLY_SDFSphere1_float = sdSphere(v_POLY_globals1_position - v_POLY_floatToVec3_1_vec3, 0.32999999999999996);\n\t\n\t// /bg/MAT/meshStandardBuilder1/SDFUnion2\n\tfloat v_POLY_SDFUnion2_union = SDFSmoothUnion(v_POLY_SDFSphere1_float, v_POLY_SDFBox2_float, 0.39);\n\t\n\t// /bg/MAT/meshStandardBuilder1/null1\n\tfloat v_POLY_null1_val = v_POLY_SDFUnion2_union;\n\t\n\t// /bg/MAT/meshStandardBuilder1/fit1\n\tfloat v_POLY_fit1_val = fit(v_POLY_null1_val, 0.0, 1.0, 0.0, 0.9);\n\t\n\t// /bg/MAT/meshStandardBuilder1/multAdd5\n\tfloat v_POLY_multAdd5_val = (1.0*(v_POLY_null1_val + -0.2)) + 0.0;\n\t\n\t// /bg/MAT/meshStandardBuilder1/complement3\n\tfloat v_POLY_complement3_val = complement(v_POLY_fit1_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/smoothstep4\n\tfloat v_POLY_smoothstep4_val = smoothstep(0.0, 0.01, v_POLY_multAdd5_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mult3\n\tfloat v_POLY_mult3_product = (v_POLY_complement3_val * v_POLY_constant3_val * 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/round1\n\tfloat v_POLY_round1_val = sign(v_POLY_mult3_product)*floor(abs(v_POLY_mult3_product)+0.5);\n\t\n\t// /bg/MAT/meshStandardBuilder1/divide1\n\tfloat v_POLY_divide1_divide = (v_POLY_round1_val / v_POLY_constant3_val / 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mix4\n\tvec3 v_POLY_mix4_mix = mix(v_POLY_rgbToOklab3_oklab, v_POLY_rgbToOklab1_oklab, v_POLY_divide1_divide);\n\t\n\t// /bg/MAT/meshStandardBuilder1/oklabToRgb1\n\tvec3 v_POLY_oklabToRgb1_rgb = linear_srgb_from_oklab(v_POLY_mix4_mix);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mix1\n\tvec3 v_POLY_mix1_mix = mix(v_POLY_oklabToRgb1_rgb, v_POLY_constant2_val, v_POLY_smoothstep4_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tdiffuseColor.xyz = v_POLY_mix1_mix;\n\tfloat POLY_metalness = 1.0;\n\tfloat POLY_roughness = 1.0;\n\tvec3 POLY_emissive = vec3(1.0, 1.0, 1.0);\n\tSSSModel POLY_SSSModel = SSSModel(/*isActive*/false,/*color*/vec3(1.0, 1.0, 1.0), /*thickness*/0.1, /*power*/2.0, /*scale*/16.0, /*distortion*/0.1,/*ambient*/0.4,/*attenuation*/0.8 );\n\n\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive * POLY_emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat roughnessFactor = roughness * POLY_roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n\n\tfloat metalnessFactor = metalness * POLY_metalness;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\nif(POLY_SSSModel.isActive){\n\tRE_Direct_Scattering(directLight, geometry, POLY_SSSModel, reflectedLight);\n}\n\n\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}","customDepthMaterial.vertex":"#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/globals1\n\tv_POLY_globals1_position = vec3(position);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}","customDepthMaterial.fragment":"\n// INSERT DEFINES\n\n\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/rgbToOklab3\n//////////////////////////////////////////////////////////////////////\n//\n// Visualizing Björn Ottosson's \"oklab\" colorspace\n//\n// shadertoy implementation by mattz\n//\n// license CC0 (public domain)\n// https://creativecommons.org/share-your-work/public-domain/cc0/\n//\n// Click and drag to set lightness (mouse x) and chroma (mouse y).\n// Hue varies linearly across the image from left to right.\n//\n// While mouse is down, plotted curves show oklab components\n// L (red), a (green), and b (blue). \n//\n// To test the inverse mapping, the plotted curves are generated\n// by mapping the (pre-clipping) linear RGB color back to oklab \n// space.\n//\n// White bars on top of the image (and black bars on the bottom of\n// the image) indicate clipping when one or more of the R, G, B \n// components are greater than 1.0 (or less than 0.0 respectively).\n//\n// The color accompanying the black/white bar shows which channels\n// are out of gamut.\n//\n// Click in the bottom left to reset the view.\n//\n// Hit the 'G' key to toggle displaying a gamut test:\n//\n//   * black pixels indicate that RGB values for some hues\n//     were clipped to 0 at the given lightness/chroma pair.\n//\n//   * white pixels indicate that RGB values for some hues\n//     were clipped to 1 at the given lightness/chroma pair\n//\n//   * gray pixels indicate that both types of clipping happened\n//\n// Hit the 'U' key to display a uniform sampling of linear sRGB \n// space, converted into oklab lightness (x position) and chroma\n// (y position) coordinates. If you mouse over a colored dot, the\n// spectrum on screen should include that exact color.\n//\n//////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////\n// sRGB color transform and inverse from \n// https://bottosson.github.io/posts/colorwrong/#what-can-we-do%3F\n\nvec3 srgb_from_linear_srgb(vec3 x) {\n\n    vec3 xlo = 12.92*x;\n    vec3 xhi = 1.055 * pow(x, vec3(0.4166666666666667)) - 0.055;\n    \n    return mix(xlo, xhi, step(vec3(0.0031308), x));\n\n}\n\nvec3 linear_srgb_from_srgb(vec3 x) {\n\n    vec3 xlo = x / 12.92;\n    vec3 xhi = pow((x + 0.055)/(1.055), vec3(2.4));\n    \n    return mix(xlo, xhi, step(vec3(0.04045), x));\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// oklab transform and inverse from\n// https://bottosson.github.io/posts/oklab/\n\n\nconst mat3 fwdA = mat3(1.0, 1.0, 1.0,\n                       0.3963377774, -0.1055613458, -0.0894841775,\n                       0.2158037573, -0.0638541728, -1.2914855480);\n                       \nconst mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,\n                       -3.3072168827, 2.6093323231, -0.7034763098,\n                       0.2307590544, -0.3411344290,  1.7068625689);\n\nconst mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,\n                       0.5362752080, 0.6807189584, 0.2818474174,\n                       0.0514575653, 0.1074065790, 0.6302613616);\n                       \nconst mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,\n                       0.7936177850, -2.4285922050, 0.7827717662,\n                       -0.0040720468, 0.4505937099, -0.8086757660);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n\n    vec3 lms = invB * c;\n            \n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n    \n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n\n    vec3 lms = fwdA * c;\n    \n    return fwdB * (lms * lms * lms);\n    \n}\n\n\n// https://www.shadertoy.com/view/WtccD7\nconst float max_chroma = 0.33;\nvec3 uvToOklab(vec3 uvw){\n\n    // setup oklab color\n    float theta = 2.*3.141592653589793*uvw.x;\n    \n    float L = 0.8;\n    float chroma = 0.1;\n    \n    //if (max(iMouse.x, iMouse.y) > 0.05 * iResolution.y) {\n        L = uvw.y;//iMouse.x / iResolution.x;\n        chroma = uvw.z * max_chroma;// / iResolution.y;\n    //}\n    \n    float a = chroma*cos(theta);\n    float b = chroma*sin(theta);\n    \n    vec3 lab = vec3(L, a, b);\n\treturn lab;\n\n    // convert to rgb \n    // vec3 rgb = linear_srgb_from_oklab(lab);\n\n}\n\n// /bg/MAT/meshStandardBuilder1/SDFBox2\n// https://iquilezles.org/articles/distfunctions/\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n/*\n*\n* SDF PRIMITIVES\n*\n*/\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n\t\tp = abs(p  )-b;\n\tvec3 q = abs(p+e)-e;\n\treturn min(min(\n\t\tlength(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n\t\tlength(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n\t\tlength(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n\tp.y -= clamp( p.y, 0.0, h );\n\treturn length( p ) - r;\n}\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n\t// c is the sin/cos of the angle, h is height\n\t// Alternatively pass q instead of (c,h),\n\t// which is the point at the base in 2D\n\tvec2 q = h*vec2(c.x/c.y,-1.0);\n\n\tvec2 w = vec2( length(p.xz), p.y );\n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n\tvec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n\tfloat k = sign( q.y );\n\tfloat d = min(dot( a, a ),dot(b, b));\n\tfloat s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\nfloat sdConeWrapped(vec3 pos, float angle, float height){\n\treturn sdCone(pos, vec2(sin(angle), cos(angle)), height);\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n\tfloat b = (r1-r2)/h;\n\tfloat a = sqrt(1.0-b*b);\n\n\tvec2 q = vec2( length(p.xz), p.y );\n\tfloat k = dot(q,vec2(-b,a));\n\tif( k<0.0 ) return length(q) - r1;\n\tif( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n\treturn dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n\t// n must be normalized\n\treturn dot(p,n) + h;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n\tp.x = abs(p.x);\n\tfloat k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n\treturn sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float radius)\n{\n\tvec2 p = vec2( length(pos.xz), pos.y );\n\tfloat l = length(p) - radius;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,radius) );\n\treturn max(l,m*sign(c.y*p.x-c.x*p.y));\n}\nfloat sdSolidAngleWrapped(vec3 pos, float angle, float radius){\n\treturn sdSolidAngle(pos, vec2(sin(angle), cos(angle)), radius);\n}\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n/*\n*\n* SDF OPERATIONS\n*\n*/\nfloat SDFUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat SDFSubtract( float d1, float d2 ) { return max(-d1,d2); }\nfloat SDFIntersect( float d1, float d2 ) { return max(d1,d2); }\n\nfloat SDFSmoothUnion( float d1, float d2, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat SDFSmoothSubtract( float d1, float d2, float k ) {\n\tfloat h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\treturn mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat SDFSmoothIntersect( float d1, float d2, float k ) {\n\tfloat h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nvec4 SDFElongateFast( in vec3 p, in vec3 h )\n{\n\treturn vec4( p-clamp(p,-h,h), 0.0 );\n}\nvec4 SDFElongateSlow( in vec3 p, in vec3 h )\n{\n\tvec3 q = abs(p)-h;\n\treturn vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat SDFOnion( in float sdf, in float thickness )\n{\n\treturn abs(sdf)-thickness;\n}\n\n// /bg/MAT/meshStandardBuilder1/fit1\n//\n//\n// FIT\n//\n//\nfloat fit(float val, float srcMin, float srcMax, float destMin, float destMax){\n\tfloat src_range = srcMax - srcMin;\n\tfloat dest_range = destMax - destMin;\n\n\tfloat r = (val - srcMin) / src_range;\n\treturn (r * dest_range) + destMin;\n}\nvec2 fit(vec2 val, vec2 srcMin, vec2 srcMax, vec2 destMin, vec2 destMax){\n\treturn vec2(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y)\n\t);\n}\nvec3 fit(vec3 val, vec3 srcMin, vec3 srcMax, vec3 destMin, vec3 destMax){\n\treturn vec3(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z)\n\t);\n}\nvec4 fit(vec4 val, vec4 srcMin, vec4 srcMax, vec4 destMin, vec4 destMax){\n\treturn vec4(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z),\n\t\tfit(val.w, srcMin.w, srcMax.w, destMin.w, destMax.w)\n\t);\n}\n\n//\n//\n// FIT TO 01\n// fits the range [srcMin, srcMax] to [0, 1]\n//\nfloat fitTo01(float val, float srcMin, float srcMax){\n\tfloat size = srcMax - srcMin;\n\treturn (val - srcMin) / size;\n}\nvec2 fitTo01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitTo01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitTo01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z),\n\t\tfitTo01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01\n// fits the range [0, 1] to [destMin, destMax]\n//\nfloat fitFrom01(float val, float destMin, float destMax){\n\treturn fit(val, 0.0, 1.0, destMin, destMax);\n}\nvec2 fitFrom01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitFrom01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitFrom01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z),\n\t\tfitFrom01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01 TO VARIANCE\n// fits the range [0, 1] to [center - variance, center + variance]\n//\nfloat fitFrom01ToVariance(float val, float center, float variance){\n\treturn fitFrom01(val, center - variance, center + variance);\n}\nvec2 fitFrom01ToVariance(vec2 val, vec2 center, vec2 variance){\n\treturn vec2(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y)\n\t);\n}\nvec3 fitFrom01ToVariance(vec3 val, vec3 center, vec3 variance){\n\treturn vec3(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z)\n\t);\n}\nvec4 fitFrom01ToVariance(vec4 val, vec4 center, vec4 variance){\n\treturn vec4(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z),\n\t\tfitFrom01ToVariance(val.w, center.w, variance.w)\n\t);\n}\n\n// /bg/MAT/meshStandardBuilder1/complement3\nfloat complement(float x){return 1.0-x;}\nvec2 complement(vec2 x){return vec2(1.0-x.x, 1.0-x.y);}\nvec3 complement(vec3 x){return vec3(1.0-x.x, 1.0-x.y, 1.0-x.z);}\nvec4 complement(vec4 x){return vec4(1.0-x.x, 1.0-x.y, 1.0-x.z, 1.0-x.w);}\n\n\n\n\n\n\n\n\n// /bg/MAT/meshStandardBuilder1/param1\nuniform vec3 v_POLY_param_blobPos;\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nstruct SSSModel {\n\tbool isActive;\n\tvec3 color;\n\tfloat thickness;\n\tfloat power;\n\tfloat scale;\n\tfloat distortion;\n\tfloat ambient;\n\tfloat attenuation;\n};\n\nvoid RE_Direct_Scattering(\n\tconst in IncidentLight directLight,\n\tconst in GeometricContext geometry,\n\tconst in SSSModel sssModel,\n\tinout ReflectedLight reflectedLight\n\t){\n\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * sssModel.distortion));\n\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), sssModel.power) * sssModel.scale;\n\tvec3 scatteringIllu = (scatteringDot + sssModel.ambient) * (sssModel.color * (1.0-sssModel.thickness));\n\treflectedLight.directDiffuse += scatteringIllu * sssModel.attenuation * directLight.color;\n}\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/constant4\n\tvec3 v_POLY_constant4_val = vec3(0.08235294117647059, 0.043137254901960784, 0.615686274509804);\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant1\n\tvec3 v_POLY_constant1_val = vec3(0.8431372549019608, 0.09803921568627451, 0.09803921568627451);\n\t\n\t// /bg/MAT/meshStandardBuilder1/param1\n\tvec3 v_POLY_param1_val = v_POLY_param_blobPos;\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant3\n\tfloat v_POLY_constant3_val = 14.0;\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant2\n\tvec3 v_POLY_constant2_val = vec3(1.0, 1.0, 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/rgbToOklab3\n\tvec3 v_POLY_rgbToOklab3_oklab = oklab_from_linear_srgb(v_POLY_constant4_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/rgbToOklab1\n\tvec3 v_POLY_rgbToOklab1_oklab = oklab_from_linear_srgb(v_POLY_constant1_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/SDFBox2\n\tfloat v_POLY_SDFBox2_float = sdBox(v_POLY_globals1_position - vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0)*0.42);\n\t\n\t// /bg/MAT/meshStandardBuilder1/vec3ToFloat1\n\tfloat v_POLY_vec3ToFloat1_x = v_POLY_param1_val.x;\n\tfloat v_POLY_vec3ToFloat1_y = v_POLY_param1_val.y;\n\t\n\t// /bg/MAT/meshStandardBuilder1/multAdd1\n\tfloat v_POLY_multAdd1_val = (1.0*(v_POLY_vec3ToFloat1_y + -0.5)) + 0.0;\n\t\n\t// /bg/MAT/meshStandardBuilder1/floatToVec3_1\n\tvec3 v_POLY_floatToVec3_1_vec3 = vec3(v_POLY_vec3ToFloat1_x, v_POLY_multAdd1_val, 0.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/SDFSphere1\n\tfloat v_POLY_SDFSphere1_float = sdSphere(v_POLY_globals1_position - v_POLY_floatToVec3_1_vec3, 0.32999999999999996);\n\t\n\t// /bg/MAT/meshStandardBuilder1/SDFUnion2\n\tfloat v_POLY_SDFUnion2_union = SDFSmoothUnion(v_POLY_SDFSphere1_float, v_POLY_SDFBox2_float, 0.39);\n\t\n\t// /bg/MAT/meshStandardBuilder1/null1\n\tfloat v_POLY_null1_val = v_POLY_SDFUnion2_union;\n\t\n\t// /bg/MAT/meshStandardBuilder1/fit1\n\tfloat v_POLY_fit1_val = fit(v_POLY_null1_val, 0.0, 1.0, 0.0, 0.9);\n\t\n\t// /bg/MAT/meshStandardBuilder1/multAdd5\n\tfloat v_POLY_multAdd5_val = (1.0*(v_POLY_null1_val + -0.2)) + 0.0;\n\t\n\t// /bg/MAT/meshStandardBuilder1/complement3\n\tfloat v_POLY_complement3_val = complement(v_POLY_fit1_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/smoothstep4\n\tfloat v_POLY_smoothstep4_val = smoothstep(0.0, 0.01, v_POLY_multAdd5_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mult3\n\tfloat v_POLY_mult3_product = (v_POLY_complement3_val * v_POLY_constant3_val * 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/round1\n\tfloat v_POLY_round1_val = sign(v_POLY_mult3_product)*floor(abs(v_POLY_mult3_product)+0.5);\n\t\n\t// /bg/MAT/meshStandardBuilder1/divide1\n\tfloat v_POLY_divide1_divide = (v_POLY_round1_val / v_POLY_constant3_val / 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mix4\n\tvec3 v_POLY_mix4_mix = mix(v_POLY_rgbToOklab3_oklab, v_POLY_rgbToOklab1_oklab, v_POLY_divide1_divide);\n\t\n\t// /bg/MAT/meshStandardBuilder1/oklabToRgb1\n\tvec3 v_POLY_oklabToRgb1_rgb = linear_srgb_from_oklab(v_POLY_mix4_mix);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mix1\n\tvec3 v_POLY_mix1_mix = mix(v_POLY_oklabToRgb1_rgb, v_POLY_constant2_val, v_POLY_smoothstep4_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tdiffuseColor.xyz = v_POLY_mix1_mix;\n\tfloat POLY_metalness = 1.0;\n\tfloat POLY_roughness = 1.0;\n\tvec3 POLY_emissive = vec3(1.0, 1.0, 1.0);\n\tSSSModel POLY_SSSModel = SSSModel(/*isActive*/false,/*color*/vec3(1.0, 1.0, 1.0), /*thickness*/0.1, /*power*/2.0, /*scale*/16.0, /*distortion*/0.1,/*ambient*/0.4,/*attenuation*/0.8 );\n\n\n\n\n\t// INSERT BODY\n\t// the new body lines should be added before the alphatest_fragment\n\t// so that alpha is set before (which is really how it would be set if the alphamap_fragment above was used by the material node parameters)\n\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), diffuseColor.a );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n","customDistanceMaterial.vertex":"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/globals1\n\tv_POLY_globals1_position = vec3(position);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}","customDistanceMaterial.fragment":"\n// INSERT DEFINES\n\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/rgbToOklab3\n//////////////////////////////////////////////////////////////////////\n//\n// Visualizing Björn Ottosson's \"oklab\" colorspace\n//\n// shadertoy implementation by mattz\n//\n// license CC0 (public domain)\n// https://creativecommons.org/share-your-work/public-domain/cc0/\n//\n// Click and drag to set lightness (mouse x) and chroma (mouse y).\n// Hue varies linearly across the image from left to right.\n//\n// While mouse is down, plotted curves show oklab components\n// L (red), a (green), and b (blue). \n//\n// To test the inverse mapping, the plotted curves are generated\n// by mapping the (pre-clipping) linear RGB color back to oklab \n// space.\n//\n// White bars on top of the image (and black bars on the bottom of\n// the image) indicate clipping when one or more of the R, G, B \n// components are greater than 1.0 (or less than 0.0 respectively).\n//\n// The color accompanying the black/white bar shows which channels\n// are out of gamut.\n//\n// Click in the bottom left to reset the view.\n//\n// Hit the 'G' key to toggle displaying a gamut test:\n//\n//   * black pixels indicate that RGB values for some hues\n//     were clipped to 0 at the given lightness/chroma pair.\n//\n//   * white pixels indicate that RGB values for some hues\n//     were clipped to 1 at the given lightness/chroma pair\n//\n//   * gray pixels indicate that both types of clipping happened\n//\n// Hit the 'U' key to display a uniform sampling of linear sRGB \n// space, converted into oklab lightness (x position) and chroma\n// (y position) coordinates. If you mouse over a colored dot, the\n// spectrum on screen should include that exact color.\n//\n//////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////\n// sRGB color transform and inverse from \n// https://bottosson.github.io/posts/colorwrong/#what-can-we-do%3F\n\nvec3 srgb_from_linear_srgb(vec3 x) {\n\n    vec3 xlo = 12.92*x;\n    vec3 xhi = 1.055 * pow(x, vec3(0.4166666666666667)) - 0.055;\n    \n    return mix(xlo, xhi, step(vec3(0.0031308), x));\n\n}\n\nvec3 linear_srgb_from_srgb(vec3 x) {\n\n    vec3 xlo = x / 12.92;\n    vec3 xhi = pow((x + 0.055)/(1.055), vec3(2.4));\n    \n    return mix(xlo, xhi, step(vec3(0.04045), x));\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// oklab transform and inverse from\n// https://bottosson.github.io/posts/oklab/\n\n\nconst mat3 fwdA = mat3(1.0, 1.0, 1.0,\n                       0.3963377774, -0.1055613458, -0.0894841775,\n                       0.2158037573, -0.0638541728, -1.2914855480);\n                       \nconst mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,\n                       -3.3072168827, 2.6093323231, -0.7034763098,\n                       0.2307590544, -0.3411344290,  1.7068625689);\n\nconst mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,\n                       0.5362752080, 0.6807189584, 0.2818474174,\n                       0.0514575653, 0.1074065790, 0.6302613616);\n                       \nconst mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,\n                       0.7936177850, -2.4285922050, 0.7827717662,\n                       -0.0040720468, 0.4505937099, -0.8086757660);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n\n    vec3 lms = invB * c;\n            \n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n    \n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n\n    vec3 lms = fwdA * c;\n    \n    return fwdB * (lms * lms * lms);\n    \n}\n\n\n// https://www.shadertoy.com/view/WtccD7\nconst float max_chroma = 0.33;\nvec3 uvToOklab(vec3 uvw){\n\n    // setup oklab color\n    float theta = 2.*3.141592653589793*uvw.x;\n    \n    float L = 0.8;\n    float chroma = 0.1;\n    \n    //if (max(iMouse.x, iMouse.y) > 0.05 * iResolution.y) {\n        L = uvw.y;//iMouse.x / iResolution.x;\n        chroma = uvw.z * max_chroma;// / iResolution.y;\n    //}\n    \n    float a = chroma*cos(theta);\n    float b = chroma*sin(theta);\n    \n    vec3 lab = vec3(L, a, b);\n\treturn lab;\n\n    // convert to rgb \n    // vec3 rgb = linear_srgb_from_oklab(lab);\n\n}\n\n// /bg/MAT/meshStandardBuilder1/SDFBox2\n// https://iquilezles.org/articles/distfunctions/\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n/*\n*\n* SDF PRIMITIVES\n*\n*/\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n\t\tp = abs(p  )-b;\n\tvec3 q = abs(p+e)-e;\n\treturn min(min(\n\t\tlength(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n\t\tlength(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n\t\tlength(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n\tp.y -= clamp( p.y, 0.0, h );\n\treturn length( p ) - r;\n}\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n\t// c is the sin/cos of the angle, h is height\n\t// Alternatively pass q instead of (c,h),\n\t// which is the point at the base in 2D\n\tvec2 q = h*vec2(c.x/c.y,-1.0);\n\n\tvec2 w = vec2( length(p.xz), p.y );\n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n\tvec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n\tfloat k = sign( q.y );\n\tfloat d = min(dot( a, a ),dot(b, b));\n\tfloat s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\nfloat sdConeWrapped(vec3 pos, float angle, float height){\n\treturn sdCone(pos, vec2(sin(angle), cos(angle)), height);\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n\tfloat b = (r1-r2)/h;\n\tfloat a = sqrt(1.0-b*b);\n\n\tvec2 q = vec2( length(p.xz), p.y );\n\tfloat k = dot(q,vec2(-b,a));\n\tif( k<0.0 ) return length(q) - r1;\n\tif( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n\treturn dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n\t// n must be normalized\n\treturn dot(p,n) + h;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n\tp.x = abs(p.x);\n\tfloat k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n\treturn sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float radius)\n{\n\tvec2 p = vec2( length(pos.xz), pos.y );\n\tfloat l = length(p) - radius;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,radius) );\n\treturn max(l,m*sign(c.y*p.x-c.x*p.y));\n}\nfloat sdSolidAngleWrapped(vec3 pos, float angle, float radius){\n\treturn sdSolidAngle(pos, vec2(sin(angle), cos(angle)), radius);\n}\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n/*\n*\n* SDF OPERATIONS\n*\n*/\nfloat SDFUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat SDFSubtract( float d1, float d2 ) { return max(-d1,d2); }\nfloat SDFIntersect( float d1, float d2 ) { return max(d1,d2); }\n\nfloat SDFSmoothUnion( float d1, float d2, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat SDFSmoothSubtract( float d1, float d2, float k ) {\n\tfloat h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\treturn mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat SDFSmoothIntersect( float d1, float d2, float k ) {\n\tfloat h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nvec4 SDFElongateFast( in vec3 p, in vec3 h )\n{\n\treturn vec4( p-clamp(p,-h,h), 0.0 );\n}\nvec4 SDFElongateSlow( in vec3 p, in vec3 h )\n{\n\tvec3 q = abs(p)-h;\n\treturn vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat SDFOnion( in float sdf, in float thickness )\n{\n\treturn abs(sdf)-thickness;\n}\n\n// /bg/MAT/meshStandardBuilder1/fit1\n//\n//\n// FIT\n//\n//\nfloat fit(float val, float srcMin, float srcMax, float destMin, float destMax){\n\tfloat src_range = srcMax - srcMin;\n\tfloat dest_range = destMax - destMin;\n\n\tfloat r = (val - srcMin) / src_range;\n\treturn (r * dest_range) + destMin;\n}\nvec2 fit(vec2 val, vec2 srcMin, vec2 srcMax, vec2 destMin, vec2 destMax){\n\treturn vec2(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y)\n\t);\n}\nvec3 fit(vec3 val, vec3 srcMin, vec3 srcMax, vec3 destMin, vec3 destMax){\n\treturn vec3(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z)\n\t);\n}\nvec4 fit(vec4 val, vec4 srcMin, vec4 srcMax, vec4 destMin, vec4 destMax){\n\treturn vec4(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z),\n\t\tfit(val.w, srcMin.w, srcMax.w, destMin.w, destMax.w)\n\t);\n}\n\n//\n//\n// FIT TO 01\n// fits the range [srcMin, srcMax] to [0, 1]\n//\nfloat fitTo01(float val, float srcMin, float srcMax){\n\tfloat size = srcMax - srcMin;\n\treturn (val - srcMin) / size;\n}\nvec2 fitTo01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitTo01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitTo01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z),\n\t\tfitTo01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01\n// fits the range [0, 1] to [destMin, destMax]\n//\nfloat fitFrom01(float val, float destMin, float destMax){\n\treturn fit(val, 0.0, 1.0, destMin, destMax);\n}\nvec2 fitFrom01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitFrom01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitFrom01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z),\n\t\tfitFrom01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01 TO VARIANCE\n// fits the range [0, 1] to [center - variance, center + variance]\n//\nfloat fitFrom01ToVariance(float val, float center, float variance){\n\treturn fitFrom01(val, center - variance, center + variance);\n}\nvec2 fitFrom01ToVariance(vec2 val, vec2 center, vec2 variance){\n\treturn vec2(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y)\n\t);\n}\nvec3 fitFrom01ToVariance(vec3 val, vec3 center, vec3 variance){\n\treturn vec3(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z)\n\t);\n}\nvec4 fitFrom01ToVariance(vec4 val, vec4 center, vec4 variance){\n\treturn vec4(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z),\n\t\tfitFrom01ToVariance(val.w, center.w, variance.w)\n\t);\n}\n\n// /bg/MAT/meshStandardBuilder1/complement3\nfloat complement(float x){return 1.0-x;}\nvec2 complement(vec2 x){return vec2(1.0-x.x, 1.0-x.y);}\nvec3 complement(vec3 x){return vec3(1.0-x.x, 1.0-x.y, 1.0-x.z);}\nvec4 complement(vec4 x){return vec4(1.0-x.x, 1.0-x.y, 1.0-x.z, 1.0-x.w);}\n\n\n\n\n\n\n\n\n// /bg/MAT/meshStandardBuilder1/param1\nuniform vec3 v_POLY_param_blobPos;\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nstruct SSSModel {\n\tbool isActive;\n\tvec3 color;\n\tfloat thickness;\n\tfloat power;\n\tfloat scale;\n\tfloat distortion;\n\tfloat ambient;\n\tfloat attenuation;\n};\n\nvoid RE_Direct_Scattering(\n\tconst in IncidentLight directLight,\n\tconst in GeometricContext geometry,\n\tconst in SSSModel sssModel,\n\tinout ReflectedLight reflectedLight\n\t){\n\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * sssModel.distortion));\n\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), sssModel.power) * sssModel.scale;\n\tvec3 scatteringIllu = (scatteringDot + sssModel.ambient) * (sssModel.color * (1.0-sssModel.thickness));\n\treflectedLight.directDiffuse += scatteringIllu * sssModel.attenuation * directLight.color;\n}\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/constant4\n\tvec3 v_POLY_constant4_val = vec3(0.08235294117647059, 0.043137254901960784, 0.615686274509804);\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant1\n\tvec3 v_POLY_constant1_val = vec3(0.8431372549019608, 0.09803921568627451, 0.09803921568627451);\n\t\n\t// /bg/MAT/meshStandardBuilder1/param1\n\tvec3 v_POLY_param1_val = v_POLY_param_blobPos;\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant3\n\tfloat v_POLY_constant3_val = 14.0;\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant2\n\tvec3 v_POLY_constant2_val = vec3(1.0, 1.0, 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/rgbToOklab3\n\tvec3 v_POLY_rgbToOklab3_oklab = oklab_from_linear_srgb(v_POLY_constant4_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/rgbToOklab1\n\tvec3 v_POLY_rgbToOklab1_oklab = oklab_from_linear_srgb(v_POLY_constant1_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/SDFBox2\n\tfloat v_POLY_SDFBox2_float = sdBox(v_POLY_globals1_position - vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0)*0.42);\n\t\n\t// /bg/MAT/meshStandardBuilder1/vec3ToFloat1\n\tfloat v_POLY_vec3ToFloat1_x = v_POLY_param1_val.x;\n\tfloat v_POLY_vec3ToFloat1_y = v_POLY_param1_val.y;\n\t\n\t// /bg/MAT/meshStandardBuilder1/multAdd1\n\tfloat v_POLY_multAdd1_val = (1.0*(v_POLY_vec3ToFloat1_y + -0.5)) + 0.0;\n\t\n\t// /bg/MAT/meshStandardBuilder1/floatToVec3_1\n\tvec3 v_POLY_floatToVec3_1_vec3 = vec3(v_POLY_vec3ToFloat1_x, v_POLY_multAdd1_val, 0.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/SDFSphere1\n\tfloat v_POLY_SDFSphere1_float = sdSphere(v_POLY_globals1_position - v_POLY_floatToVec3_1_vec3, 0.32999999999999996);\n\t\n\t// /bg/MAT/meshStandardBuilder1/SDFUnion2\n\tfloat v_POLY_SDFUnion2_union = SDFSmoothUnion(v_POLY_SDFSphere1_float, v_POLY_SDFBox2_float, 0.39);\n\t\n\t// /bg/MAT/meshStandardBuilder1/null1\n\tfloat v_POLY_null1_val = v_POLY_SDFUnion2_union;\n\t\n\t// /bg/MAT/meshStandardBuilder1/fit1\n\tfloat v_POLY_fit1_val = fit(v_POLY_null1_val, 0.0, 1.0, 0.0, 0.9);\n\t\n\t// /bg/MAT/meshStandardBuilder1/multAdd5\n\tfloat v_POLY_multAdd5_val = (1.0*(v_POLY_null1_val + -0.2)) + 0.0;\n\t\n\t// /bg/MAT/meshStandardBuilder1/complement3\n\tfloat v_POLY_complement3_val = complement(v_POLY_fit1_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/smoothstep4\n\tfloat v_POLY_smoothstep4_val = smoothstep(0.0, 0.01, v_POLY_multAdd5_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mult3\n\tfloat v_POLY_mult3_product = (v_POLY_complement3_val * v_POLY_constant3_val * 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/round1\n\tfloat v_POLY_round1_val = sign(v_POLY_mult3_product)*floor(abs(v_POLY_mult3_product)+0.5);\n\t\n\t// /bg/MAT/meshStandardBuilder1/divide1\n\tfloat v_POLY_divide1_divide = (v_POLY_round1_val / v_POLY_constant3_val / 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mix4\n\tvec3 v_POLY_mix4_mix = mix(v_POLY_rgbToOklab3_oklab, v_POLY_rgbToOklab1_oklab, v_POLY_divide1_divide);\n\t\n\t// /bg/MAT/meshStandardBuilder1/oklabToRgb1\n\tvec3 v_POLY_oklabToRgb1_rgb = linear_srgb_from_oklab(v_POLY_mix4_mix);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mix1\n\tvec3 v_POLY_mix1_mix = mix(v_POLY_oklabToRgb1_rgb, v_POLY_constant2_val, v_POLY_smoothstep4_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tdiffuseColor.xyz = v_POLY_mix1_mix;\n\tfloat POLY_metalness = 1.0;\n\tfloat POLY_roughness = 1.0;\n\tvec3 POLY_emissive = vec3(1.0, 1.0, 1.0);\n\tSSSModel POLY_SSSModel = SSSModel(/*isActive*/false,/*color*/vec3(1.0, 1.0, 1.0), /*thickness*/0.1, /*power*/2.0, /*scale*/16.0, /*distortion*/0.1,/*ambient*/0.4,/*attenuation*/0.8 );\n\n\n\n\n\t// INSERT BODY\n\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n","customDepthDOFMaterial.vertex":"#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n// removed:\n//\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n// removed:\n//\t#include <begin_vertex>\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/globals1\n\tv_POLY_globals1_position = vec3(position);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tvec3 transformed = position;\n\tvec3 objectNormal = normal;\n\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t#endif\n\n\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}","customDepthDOFMaterial.fragment":"\n// INSERT DEFINES\n\n\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n\n\n\n// /bg/MAT/meshStandardBuilder1/rgbToOklab3\n//////////////////////////////////////////////////////////////////////\n//\n// Visualizing Björn Ottosson's \"oklab\" colorspace\n//\n// shadertoy implementation by mattz\n//\n// license CC0 (public domain)\n// https://creativecommons.org/share-your-work/public-domain/cc0/\n//\n// Click and drag to set lightness (mouse x) and chroma (mouse y).\n// Hue varies linearly across the image from left to right.\n//\n// While mouse is down, plotted curves show oklab components\n// L (red), a (green), and b (blue). \n//\n// To test the inverse mapping, the plotted curves are generated\n// by mapping the (pre-clipping) linear RGB color back to oklab \n// space.\n//\n// White bars on top of the image (and black bars on the bottom of\n// the image) indicate clipping when one or more of the R, G, B \n// components are greater than 1.0 (or less than 0.0 respectively).\n//\n// The color accompanying the black/white bar shows which channels\n// are out of gamut.\n//\n// Click in the bottom left to reset the view.\n//\n// Hit the 'G' key to toggle displaying a gamut test:\n//\n//   * black pixels indicate that RGB values for some hues\n//     were clipped to 0 at the given lightness/chroma pair.\n//\n//   * white pixels indicate that RGB values for some hues\n//     were clipped to 1 at the given lightness/chroma pair\n//\n//   * gray pixels indicate that both types of clipping happened\n//\n// Hit the 'U' key to display a uniform sampling of linear sRGB \n// space, converted into oklab lightness (x position) and chroma\n// (y position) coordinates. If you mouse over a colored dot, the\n// spectrum on screen should include that exact color.\n//\n//////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////\n// sRGB color transform and inverse from \n// https://bottosson.github.io/posts/colorwrong/#what-can-we-do%3F\n\nvec3 srgb_from_linear_srgb(vec3 x) {\n\n    vec3 xlo = 12.92*x;\n    vec3 xhi = 1.055 * pow(x, vec3(0.4166666666666667)) - 0.055;\n    \n    return mix(xlo, xhi, step(vec3(0.0031308), x));\n\n}\n\nvec3 linear_srgb_from_srgb(vec3 x) {\n\n    vec3 xlo = x / 12.92;\n    vec3 xhi = pow((x + 0.055)/(1.055), vec3(2.4));\n    \n    return mix(xlo, xhi, step(vec3(0.04045), x));\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// oklab transform and inverse from\n// https://bottosson.github.io/posts/oklab/\n\n\nconst mat3 fwdA = mat3(1.0, 1.0, 1.0,\n                       0.3963377774, -0.1055613458, -0.0894841775,\n                       0.2158037573, -0.0638541728, -1.2914855480);\n                       \nconst mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,\n                       -3.3072168827, 2.6093323231, -0.7034763098,\n                       0.2307590544, -0.3411344290,  1.7068625689);\n\nconst mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,\n                       0.5362752080, 0.6807189584, 0.2818474174,\n                       0.0514575653, 0.1074065790, 0.6302613616);\n                       \nconst mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,\n                       0.7936177850, -2.4285922050, 0.7827717662,\n                       -0.0040720468, 0.4505937099, -0.8086757660);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n\n    vec3 lms = invB * c;\n            \n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n    \n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n\n    vec3 lms = fwdA * c;\n    \n    return fwdB * (lms * lms * lms);\n    \n}\n\n\n// https://www.shadertoy.com/view/WtccD7\nconst float max_chroma = 0.33;\nvec3 uvToOklab(vec3 uvw){\n\n    // setup oklab color\n    float theta = 2.*3.141592653589793*uvw.x;\n    \n    float L = 0.8;\n    float chroma = 0.1;\n    \n    //if (max(iMouse.x, iMouse.y) > 0.05 * iResolution.y) {\n        L = uvw.y;//iMouse.x / iResolution.x;\n        chroma = uvw.z * max_chroma;// / iResolution.y;\n    //}\n    \n    float a = chroma*cos(theta);\n    float b = chroma*sin(theta);\n    \n    vec3 lab = vec3(L, a, b);\n\treturn lab;\n\n    // convert to rgb \n    // vec3 rgb = linear_srgb_from_oklab(lab);\n\n}\n\n// /bg/MAT/meshStandardBuilder1/SDFBox2\n// https://iquilezles.org/articles/distfunctions/\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n/*\n*\n* SDF PRIMITIVES\n*\n*/\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n\t\tp = abs(p  )-b;\n\tvec3 q = abs(p+e)-e;\n\treturn min(min(\n\t\tlength(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n\t\tlength(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n\t\tlength(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n\tp.y -= clamp( p.y, 0.0, h );\n\treturn length( p ) - r;\n}\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n\t// c is the sin/cos of the angle, h is height\n\t// Alternatively pass q instead of (c,h),\n\t// which is the point at the base in 2D\n\tvec2 q = h*vec2(c.x/c.y,-1.0);\n\n\tvec2 w = vec2( length(p.xz), p.y );\n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n\tvec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n\tfloat k = sign( q.y );\n\tfloat d = min(dot( a, a ),dot(b, b));\n\tfloat s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\nfloat sdConeWrapped(vec3 pos, float angle, float height){\n\treturn sdCone(pos, vec2(sin(angle), cos(angle)), height);\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n\tfloat b = (r1-r2)/h;\n\tfloat a = sqrt(1.0-b*b);\n\n\tvec2 q = vec2( length(p.xz), p.y );\n\tfloat k = dot(q,vec2(-b,a));\n\tif( k<0.0 ) return length(q) - r1;\n\tif( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n\treturn dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n\t// n must be normalized\n\treturn dot(p,n) + h;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n\tp.x = abs(p.x);\n\tfloat k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n\treturn sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float radius)\n{\n\tvec2 p = vec2( length(pos.xz), pos.y );\n\tfloat l = length(p) - radius;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,radius) );\n\treturn max(l,m*sign(c.y*p.x-c.x*p.y));\n}\nfloat sdSolidAngleWrapped(vec3 pos, float angle, float radius){\n\treturn sdSolidAngle(pos, vec2(sin(angle), cos(angle)), radius);\n}\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n/*\n*\n* SDF OPERATIONS\n*\n*/\nfloat SDFUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat SDFSubtract( float d1, float d2 ) { return max(-d1,d2); }\nfloat SDFIntersect( float d1, float d2 ) { return max(d1,d2); }\n\nfloat SDFSmoothUnion( float d1, float d2, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat SDFSmoothSubtract( float d1, float d2, float k ) {\n\tfloat h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\treturn mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat SDFSmoothIntersect( float d1, float d2, float k ) {\n\tfloat h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nvec4 SDFElongateFast( in vec3 p, in vec3 h )\n{\n\treturn vec4( p-clamp(p,-h,h), 0.0 );\n}\nvec4 SDFElongateSlow( in vec3 p, in vec3 h )\n{\n\tvec3 q = abs(p)-h;\n\treturn vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat SDFOnion( in float sdf, in float thickness )\n{\n\treturn abs(sdf)-thickness;\n}\n\n// /bg/MAT/meshStandardBuilder1/fit1\n//\n//\n// FIT\n//\n//\nfloat fit(float val, float srcMin, float srcMax, float destMin, float destMax){\n\tfloat src_range = srcMax - srcMin;\n\tfloat dest_range = destMax - destMin;\n\n\tfloat r = (val - srcMin) / src_range;\n\treturn (r * dest_range) + destMin;\n}\nvec2 fit(vec2 val, vec2 srcMin, vec2 srcMax, vec2 destMin, vec2 destMax){\n\treturn vec2(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y)\n\t);\n}\nvec3 fit(vec3 val, vec3 srcMin, vec3 srcMax, vec3 destMin, vec3 destMax){\n\treturn vec3(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z)\n\t);\n}\nvec4 fit(vec4 val, vec4 srcMin, vec4 srcMax, vec4 destMin, vec4 destMax){\n\treturn vec4(\n\t\tfit(val.x, srcMin.x, srcMax.x, destMin.x, destMax.x),\n\t\tfit(val.y, srcMin.y, srcMax.y, destMin.y, destMax.y),\n\t\tfit(val.z, srcMin.z, srcMax.z, destMin.z, destMax.z),\n\t\tfit(val.w, srcMin.w, srcMax.w, destMin.w, destMax.w)\n\t);\n}\n\n//\n//\n// FIT TO 01\n// fits the range [srcMin, srcMax] to [0, 1]\n//\nfloat fitTo01(float val, float srcMin, float srcMax){\n\tfloat size = srcMax - srcMin;\n\treturn (val - srcMin) / size;\n}\nvec2 fitTo01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitTo01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitTo01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitTo01(val.x, srcMin.x, srcMax.x),\n\t\tfitTo01(val.y, srcMin.y, srcMax.y),\n\t\tfitTo01(val.z, srcMin.z, srcMax.z),\n\t\tfitTo01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01\n// fits the range [0, 1] to [destMin, destMax]\n//\nfloat fitFrom01(float val, float destMin, float destMax){\n\treturn fit(val, 0.0, 1.0, destMin, destMax);\n}\nvec2 fitFrom01(vec2 val, vec2 srcMin, vec2 srcMax){\n\treturn vec2(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y)\n\t);\n}\nvec3 fitFrom01(vec3 val, vec3 srcMin, vec3 srcMax){\n\treturn vec3(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z)\n\t);\n}\nvec4 fitFrom01(vec4 val, vec4 srcMin, vec4 srcMax){\n\treturn vec4(\n\t\tfitFrom01(val.x, srcMin.x, srcMax.x),\n\t\tfitFrom01(val.y, srcMin.y, srcMax.y),\n\t\tfitFrom01(val.z, srcMin.z, srcMax.z),\n\t\tfitFrom01(val.w, srcMin.w, srcMax.w)\n\t);\n}\n\n//\n//\n// FIT FROM 01 TO VARIANCE\n// fits the range [0, 1] to [center - variance, center + variance]\n//\nfloat fitFrom01ToVariance(float val, float center, float variance){\n\treturn fitFrom01(val, center - variance, center + variance);\n}\nvec2 fitFrom01ToVariance(vec2 val, vec2 center, vec2 variance){\n\treturn vec2(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y)\n\t);\n}\nvec3 fitFrom01ToVariance(vec3 val, vec3 center, vec3 variance){\n\treturn vec3(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z)\n\t);\n}\nvec4 fitFrom01ToVariance(vec4 val, vec4 center, vec4 variance){\n\treturn vec4(\n\t\tfitFrom01ToVariance(val.x, center.x, variance.x),\n\t\tfitFrom01ToVariance(val.y, center.y, variance.y),\n\t\tfitFrom01ToVariance(val.z, center.z, variance.z),\n\t\tfitFrom01ToVariance(val.w, center.w, variance.w)\n\t);\n}\n\n// /bg/MAT/meshStandardBuilder1/complement3\nfloat complement(float x){return 1.0-x;}\nvec2 complement(vec2 x){return vec2(1.0-x.x, 1.0-x.y);}\nvec3 complement(vec3 x){return vec3(1.0-x.x, 1.0-x.y, 1.0-x.z);}\nvec4 complement(vec4 x){return vec4(1.0-x.x, 1.0-x.y, 1.0-x.z, 1.0-x.w);}\n\n\n\n\n\n\n\n\n// /bg/MAT/meshStandardBuilder1/param1\nuniform vec3 v_POLY_param_blobPos;\n\n// /bg/MAT/meshStandardBuilder1/globals1\nvarying vec3 v_POLY_globals1_position;\n\n\n\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nstruct SSSModel {\n\tbool isActive;\n\tvec3 color;\n\tfloat thickness;\n\tfloat power;\n\tfloat scale;\n\tfloat distortion;\n\tfloat ambient;\n\tfloat attenuation;\n};\n\nvoid RE_Direct_Scattering(\n\tconst in IncidentLight directLight,\n\tconst in GeometricContext geometry,\n\tconst in SSSModel sssModel,\n\tinout ReflectedLight reflectedLight\n\t){\n\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * sssModel.distortion));\n\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), sssModel.power) * sssModel.scale;\n\tvec3 scatteringIllu = (scatteringDot + sssModel.ambient) * (sssModel.color * (1.0-sssModel.thickness));\n\treflectedLight.directDiffuse += scatteringIllu * sssModel.attenuation * directLight.color;\n}\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\n\n\n\t// /bg/MAT/meshStandardBuilder1/constant4\n\tvec3 v_POLY_constant4_val = vec3(0.08235294117647059, 0.043137254901960784, 0.615686274509804);\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant1\n\tvec3 v_POLY_constant1_val = vec3(0.8431372549019608, 0.09803921568627451, 0.09803921568627451);\n\t\n\t// /bg/MAT/meshStandardBuilder1/param1\n\tvec3 v_POLY_param1_val = v_POLY_param_blobPos;\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant3\n\tfloat v_POLY_constant3_val = 14.0;\n\t\n\t// /bg/MAT/meshStandardBuilder1/constant2\n\tvec3 v_POLY_constant2_val = vec3(1.0, 1.0, 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/rgbToOklab3\n\tvec3 v_POLY_rgbToOklab3_oklab = oklab_from_linear_srgb(v_POLY_constant4_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/rgbToOklab1\n\tvec3 v_POLY_rgbToOklab1_oklab = oklab_from_linear_srgb(v_POLY_constant1_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/SDFBox2\n\tfloat v_POLY_SDFBox2_float = sdBox(v_POLY_globals1_position - vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0)*0.42);\n\t\n\t// /bg/MAT/meshStandardBuilder1/vec3ToFloat1\n\tfloat v_POLY_vec3ToFloat1_x = v_POLY_param1_val.x;\n\tfloat v_POLY_vec3ToFloat1_y = v_POLY_param1_val.y;\n\t\n\t// /bg/MAT/meshStandardBuilder1/multAdd1\n\tfloat v_POLY_multAdd1_val = (1.0*(v_POLY_vec3ToFloat1_y + -0.5)) + 0.0;\n\t\n\t// /bg/MAT/meshStandardBuilder1/floatToVec3_1\n\tvec3 v_POLY_floatToVec3_1_vec3 = vec3(v_POLY_vec3ToFloat1_x, v_POLY_multAdd1_val, 0.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/SDFSphere1\n\tfloat v_POLY_SDFSphere1_float = sdSphere(v_POLY_globals1_position - v_POLY_floatToVec3_1_vec3, 0.32999999999999996);\n\t\n\t// /bg/MAT/meshStandardBuilder1/SDFUnion2\n\tfloat v_POLY_SDFUnion2_union = SDFSmoothUnion(v_POLY_SDFSphere1_float, v_POLY_SDFBox2_float, 0.39);\n\t\n\t// /bg/MAT/meshStandardBuilder1/null1\n\tfloat v_POLY_null1_val = v_POLY_SDFUnion2_union;\n\t\n\t// /bg/MAT/meshStandardBuilder1/fit1\n\tfloat v_POLY_fit1_val = fit(v_POLY_null1_val, 0.0, 1.0, 0.0, 0.9);\n\t\n\t// /bg/MAT/meshStandardBuilder1/multAdd5\n\tfloat v_POLY_multAdd5_val = (1.0*(v_POLY_null1_val + -0.2)) + 0.0;\n\t\n\t// /bg/MAT/meshStandardBuilder1/complement3\n\tfloat v_POLY_complement3_val = complement(v_POLY_fit1_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/smoothstep4\n\tfloat v_POLY_smoothstep4_val = smoothstep(0.0, 0.01, v_POLY_multAdd5_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mult3\n\tfloat v_POLY_mult3_product = (v_POLY_complement3_val * v_POLY_constant3_val * 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/round1\n\tfloat v_POLY_round1_val = sign(v_POLY_mult3_product)*floor(abs(v_POLY_mult3_product)+0.5);\n\t\n\t// /bg/MAT/meshStandardBuilder1/divide1\n\tfloat v_POLY_divide1_divide = (v_POLY_round1_val / v_POLY_constant3_val / 1.0);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mix4\n\tvec3 v_POLY_mix4_mix = mix(v_POLY_rgbToOklab3_oklab, v_POLY_rgbToOklab1_oklab, v_POLY_divide1_divide);\n\t\n\t// /bg/MAT/meshStandardBuilder1/oklabToRgb1\n\tvec3 v_POLY_oklabToRgb1_rgb = linear_srgb_from_oklab(v_POLY_mix4_mix);\n\t\n\t// /bg/MAT/meshStandardBuilder1/mix1\n\tvec3 v_POLY_mix1_mix = mix(v_POLY_oklabToRgb1_rgb, v_POLY_constant2_val, v_POLY_smoothstep4_val);\n\t\n\t// /bg/MAT/meshStandardBuilder1/output1\n\tdiffuseColor.xyz = v_POLY_mix1_mix;\n\tfloat POLY_metalness = 1.0;\n\tfloat POLY_roughness = 1.0;\n\tvec3 POLY_emissive = vec3(1.0, 1.0, 1.0);\n\tSSSModel POLY_SSSModel = SSSModel(/*isActive*/false,/*color*/vec3(1.0, 1.0, 1.0), /*thickness*/0.1, /*power*/2.0, /*scale*/16.0, /*distortion*/0.1,/*ambient*/0.4,/*attenuation*/0.8 );\n\n\n\n\n\t// INSERT BODY\n\t// the new body lines should be added before the alphatest_fragment\n\t// so that alpha is set before (which is really how it would be set if the alphamap_fragment above was used by the material node parameters)\n\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), diffuseColor.a );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n"}}};
	return loadScene_scene_02(options);
};
